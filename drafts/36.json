{
  "id": "36",
  "name": "מנמ\"א ממ\"ן 14 שאלה 4",
  "body": "נכנה את מבנה הנתונים הנדרש בפשטות \"טבלת ציונים\" – `Grade-Table`. \nתחילה, את האיבר השכיח ביותר בטבלה אפשר למצוא בזמן לינארי (ביחס לגודל הטבלה, כלומר $O(nm)$) אם נבנה מערך $C[0..100]$ של מספר ההפועות של כל ציון בטבלה, כמו במיון מנייה, ונחפש בו את האיבר המקסימלי באופן הסטנדרטי, ע\"י מעבר על כל האיברים. בשל העובדה שהמבנה סטטי, אפשר לבצע את כל העבודה הזו כשבונים את מבנה הנתונים, ולשמור בו רק את התוצאה.\nבנוסף, נשים לב שפעולות החזרת הממוצע של סטודנט מסוים בכל הקורסים, או של כל הסטודנטים בקורס מסוים, מתקבלות כמקרה פרטי של פעולת החזרת הממוצע בחתך כלשהו בטבלה (כשהחתך הוא עמודה יחידה או שורה יחידה, בהתאמה). כדי לממש את הפעולה הזו בזמן $O(1)$, אפשר להשתמש בעיקרון הבא: בהינתן חתך $(r_1,c_1,r_2,c_2)$, ממוצע הערכים בו הוא סכום כל הערכים בחתך חלקי מספר האיברים בו, שהוא $(r_2-r_1+1)(c_2-c_1+1)$. לכן, חישוב הממוצע בחתך בזמן $O(1)$ שקול לחישוב הסכום בו בזמן $O(1)$. \nכדי לחשב את הסכומים מתוך טבלה $A$ נבנה טבלה נוספת $T$, כך שהאיבר $T[r,c]$ יכיל את סכום החתך $(1,1,r,c)$; כפי שנראה להלן, לא קשה לעשות זאת בזמן $O(nm)$. בהינתן חתך כללי $(r_1,c_1,r_2,c_2)$, נשתמש בפירוק\n$$(1,1,r_2,c_2)=(1,1,r_1-1,c_2)\\cup (1,1,r_2,c_1-1)\\cup (r_1,c_1,r_2,c_2)$$\n (אנחנו מזהים כאן את הקואורדינטות שמייצגות את החתך עם קבוצת האיברים שנמצאת בחתך הזה).\n החיתוך של שני החתכים הראשונים משמאל הוא $(1,1,r_1-1,c_1-1)$, ושניהם זרים לחתך השלישי. ולכן נקבל את הנוסחה\n$$\\sum_{(i,j)\\in (r_1,c_1,r_2,c_2)}A[i,j]=T[r_2,c_2]-T[r_1-1,c_2]-T[r_2,c_1-1]+T[r_1-1,c_1-1]$$\nולכן בהינתן הטבלה $T$, חישוב הסכום (ולכן גם הממוצע) בכל חתך מתקבל בזמן $O(1)$.\n\nכעת נתאר את מבנה הנתונים באופן מפורש: מימוש מבנה הנתונים `Grade-Table` מתבצע בעזרת טבלה $T$ בגודל $n\\times m$ (כלומר, גודלה זהה לגודל הטבלה $A$ שממנה נבנה מבנה הנתונים). השדה $\\operatorname*{width}[T]=m$ מתאר את רוחב הטבלה, או לחילופין את מספר הסטודנטים, והשדה $\\operatorname*{height}[T]=n$ מתאר את גובהה, או לחילופין את מספר הקורסים. בנוסף, יש לטבלה שדה $\\operatorname*{mode}[T]$ שמצביע על הציון השכיח ביותר בטבלה $A$.\n\nהפעולה `Build-Grade-Table(A)` בונה את טבלת הציונים מתוך טבלה נתונה $A$ שעונה על הדרישות בשאלה. אנחנו מניחים שהפעולה `Copy(A)` מקבלת טבלה ומחזירה עותק שלה, עם אותם ממדים ואותם ערכים; אם אין צורך לשמור על הטבלה $A$, כלומר מותר \"להרוס\" אותה, אז אין צורך בפעולה זו, ואפשר לבצע את כל הפעולות על $A$ ישירות (אלא שאז צריך למצוא את הציון השכיח ביותר לפני שמשנים את הטבלה, כלומר החלק השני בפעולה צריך להופיע לפני הראשון)\n``` {.numberLines}\nBuild-Grade-Table(A)\n  ▷ Build the sum table T\n  T ← Copy(A)\n  for i ← 1 to height[T]\n    for j ← 2 to width[T]\n      T[i,j] ← T[i,j] + T[i,j-1]\n\n  for i ← 2 to height[T]\n    for j ← 1 to width[T]\n      T[i,j] ← T[i,j] + T[i-1, j]\n\n  ▷ Find the mode\n  Create array C[0..100]\n  for i ← 1 to height[A]\n    for j ← 1 to width[A]\n      grade ← A[i,j]\n      C[grade] ← C[grade] + 1\n\n  ▷ C[i] now contains the amount of occurences of the grade i.\n  mode[T] ← Maximum(C)\n\n  return T\n```\nאת מציאת הציון השכיח ביותר הסברנו לעיל, לכן נתמקד בבניית הטבלה. \nנסמן ב-$T_0=A$ את ערכי הטבלה $T$ לפני הלולאה הראשונה, ב-$T_1$ אחרי הלולאה הראשונה וב-$T_2$ אחרי הלולאה השנייה (כלומר בסוף הריצה). באינדוקציה פשוטה נקבל שבתום הריצה הראשונה כל איבר ב-$T$ מכיל את סכום כל האיברים שהופיעו מתחילת השורה שלו עד אליו (כולל), כלומר\n$$T_1[r,c]=T_0[r,1]+...+T_0[r,c]=A[r,1]+...+A[r,c]$$\nבאופן דומה, בתום הריצה השנייה כל איבר ב-$T$ מכיל את סכום כל האיברים שהופיעו מתחילת העמודה שלו עד אליו, כלומר\n$$T_2[r,c]=T_1[1,c]+...+T_1[r,c]$$\nיחד נקבל\n$$T_2[r,c]=\\sum_{i=1}^rT_1[i,c]=\\sum_{i=1}^r\\sum_{j=1}^cA[i,j]$$\nכנדרש.\n\nבאשר לסיבוכיות הזמן של הפעולה, שלוש הלולאות רצות בזמן $\\Theta(mn)$, שכן כל איטרציה בכל אחת מהן היא $\\Theta(1)$ והן מבצעות $m(n-1),(m-1)n$ ו-$mn$ איטרציות בהתאמה. גם ההעתקה, אם לא דורסים את הטבלה המקורית $A$, רצה בזמן $\\Theta(mn)$. למערך $C[0..100]$ אורך קבוע, לכן מציאת המקסימום בו אורכת $\\Theta(1)$, ויחד נקבל שבניית הטבלה אורכת $\\Theta(mn)$, כנדרש. \nמלבד משתני עזר ספורים, הפעולה משתמשת בטבלה החדשה $T$, אם אכן מעתיקים את $A$, ובמערך השכיחויות $C$. ל-$C$ סיבוכיות מקום $\\Theta(1)$ כי אורכו קבוע, ולכן סיבוכיות המקום של הפעולה – ושל מבנה הנתונים בכלל – היא $\\Theta(nm)$ אם מעתיקים את הטבלה $A$, ו-$\\Theta(1)$ אם דורסים אותה.\n\nהפעולה `Most-Frequent-Grade(T)` מחזירה את הציון הנפוץ ביותר בטבלה:\n``` {.numberLines}\nMost-Frequent-Grade(T)\n  return mode[T]\n```\n\nלחילופין, אפשר היה פשוט לגשת ל-$\\operatorname*{mode}[T]$ ישירות. סיבוכיות הזמן והמקום של הפעולה הן $\\Theta(1)$.\n\nהפעולה `Slice-Average(T, r1,c1,r2,c2)` מחזירה את הממוצע לאורך חתך כלשהו בטבלה; הפעולות \n`Student-Average(T, j)` ו-`Course-Average(T, i)` מחזירות את ממוצע הציונים של סטודנט מסוים (באינדקס $j$) או של קורס מסוים (באינדקס $i$):\n``` {.numberLines}\nSlice-Average(T,r1,c1,r2,c2)\n  sum ← T[r2,c2]-T[r1-1,c2]-T[r2,c1-1]+T[r1-1,c1-1]\n  quant ← (r2-r1+1)(c2-c1+1)\n  return sum / quant\n\nStudent-Average(T,j)\n  return Slice-Average(T, 1, j, height[T], j)\n\nCourse-Average(T, i)\n  return Slice-Average(T, i, 1, i, width[T])\n```\n$\\square$\n"
}