{
  "id": "42",
  "name": "שאלה 4",
  "body": "נדרש מבנה נתונים $S$ שמאפשר להחזיק ולערוך קבוצה של נקודות במישור (ללא חזרות), ושתומך בפעולות המפורטות. \nמספר הנקודות השונות הוא $n$, ויש בהן $m_1,m_2$ ערכים ייחודיים לרכיבים הראשונים והשניים, בהתאמה.\n\nנגדיר את המבנה הנדרש $S$ כהרחבה של עץ אדום שחור, באופן הבא: המפתחות בעץ $S$ מתאימים לערכי הרכיבים הראשונים של $n$ הנקודות (בפרט, גודל העץ $S$ הוא $m_1$). נוסף על שדה המפתח ועל המידע הנדרש לתפקוד העץ האדום-שחור,  לכל צומת $v$ ב-$S$ יש גם שדה $\\operatorname*{ys}[v]$, שמצביע על מבנה נתונים נוסף $T$; $T$ גם הוא מתקבל כהרחבה של עץ אדום-שחור, והמפתחות בו מתאימים לערכי הרכיבים השניים של הנקודות, כך שהעץ $\\operatorname*{ys}[x]$ מכיל בדיוק את הערכים $y$ שעבורם $(x,y)$ היא נקודה באוסף. \nבניסוח אחר, העץ מחלק את כל הנקודות תחילה לפי הרכיב הראשון, במובן זה שהמפתחות ב-$S$ הם הרכיבים הראשונים של $n$ הנקודות, ואחר כך מארגן את כל הנקודות בכל תא לעץ אדום-שחור מורחב (בפועל שומרים בכל תא פנימי רק את הרכיב השני, כדי להימנע ממידע מיותר). \n\nעוד לפני השדות הנוספים, ארגון המידע באופן זה כבר מאפשר לנו לממש חיפוש, הכנסה ומחיקה בסיבוכיות הדרושה, באופן הבא: בהינתן $S$ ונקודה $(x,y)$ שמבקשים לחפש, להוסיף או למחוק, תחילה מחפשים את המפתח $x$ ב-$S$. אם הוא נמצא, מחפשים/מכניסים/מוחקים בשדה $\\operatorname*{ys}[x]$ שלו את $y$, בהתאמה, ואחרת יוצרים את העץ בהכנסה, מחזירים `NIL` בחיפוש ולא עושים כלום במחיקה:\n```{.numberLines}\nSearch(S, (x,y))\n  node ← Tree-Search(S, x)\n  if node = nil[S]\n    return NIL\n  return Tree-Search(ys[node], y)\n\nInsert(S, (x,y))\n  node ← Tree-Search(S, x)\n  if node = nil[S]\n    ▷ Assuming this also initializes the augmented fields below\n    node ← Tree-Insert(S, x) \n  Tree-Insert(ys[node], y)\n\nDelete(S, (x,y))\n  node ← Tree-Search(S, x)\n  if node ≠ nil[S]\n    Tree-Delete(ys[node], y)\n```\n\nסיבוכיות הזמן של חיפוש, הכנסה ומחיקה בעץ אדום-שחור בעל $k$ איברים היא $O(\\log k)$. בכל אחת מהפעולות כאן מבצעים פעולה או שתיים על העץ $S$, שגודלו $m_1$, ופעולה אחת על עץ מסוג $T$, שגודלו לכל היותר $m_2$. לכן סיבוכיות הזמן הכוללת של שלוש הפעולות היא\n$$O(\\log m_1+\\log m_2)$$\nכנדרש. סיבוכיות המקום של שלושתן היא $O(1)$.\n\nכדי לתמוך בשתי הפעולות הנוספות `Print-Mean(S,k)` ו-`Print-Min2(S,k)` עלינו להוסיף גם ל-$T$ וגם ל-$S$ שדות נוספים:\nלעץ האדום-שחור $T$ נוסיף שלושה שדות: \n- $\\operatorname*{size}[v]$, שמכיל את גודל העץ שנפרש תחת $v$ (כולל $v$), ומקיים\n$$\\operatorname*{size}[v]=1+\\operatorname*{size}[\\operatorname*{left}[v]]+\\operatorname*{size}[\\operatorname*{right}[v]]$$\n- $\\operatorname*{sum}[v]$, שמכיל את סכום המפתחות בעץ שנפרש תחת $v$, ומקיים\n$$\\operatorname*{sum}[v]=\\operatorname*{key}[v]+\\operatorname*{sum}[\\operatorname*{left}[v]]+\\operatorname*{sum}[\\operatorname*{right}[v]]$$\n- $\\operatorname*{min}[v]$, שמכיל את המינימום מבין ערכי המפתחות בתת-עץ שנפרש תחת $v$, ומקיים \n$$\\operatorname*{min}[v]=\\min(\\operatorname*{key}[v], \\operatorname{min}[\\operatorname*{left}[v]], \\operatorname*{min}[\\operatorname*{right}[v]])$$\n(עבור הזקיף $\\operatorname*{nil}[T]$, שלושתם מקבלים את הערך $0$). מהנוסחאות לעיל עולה שכל השדות מקיימים את התנאי שבמשפט 14.1, כלומר אפשר להוסיף אותם לעץ האדום-שחור $T$ מבלי לשנות את הסיבוכיות האסימפטוטית של פעולות ההכנסה והמחיקה $O(\\log n)$. לשם הנוחות, בהינתן צומת $u$ ב-$S$, נתייחס ל-\n$$\\begin{aligned}\n\\operatorname*{node-size}[u]&:=\\operatorname*{size}[root[ys[u]]] \\\\\n\\operatorname*{node-sum}[u]&:=\\operatorname*{sum}[root[ys[u]]] \\\\\n\\operatorname*{node-min}[u]&:=\\operatorname*{min}[root[ys[u]]]\n\\end{aligned}$$\nכאל שדות של הצומת $u$.\nגם לעץ $S$ נוסיף שלושה שדות: $\\operatorname*{subtree-size}[v]$, $\\operatorname*{subtree-sum}[v]$ ו-$\\operatorname*{subtree-min}[v]$, שמכילים בהתאמה את הסכומים והמינימום של $\\operatorname*{node-size}[u]$, $\\operatorname*{node-sum}[u]$ ו-$\\operatorname*{node-min}[u]$ על פני כל הצמתים $u$ בתת-עץ שנפרש תחת $v$. גם שדות אלו מקיימים את התנאי של משפט 14.1, עם נוסחאות זהות במהות:\n$$\\begin{aligned}\n\\operatorname*{subtree-size}[v]&=\\operatorname*{node-size}[v]+\\operatorname*{subtree-size}[\\operatorname*{left}[v]]+\\operatorname*{subtree-size}[\\operatorname*{right}[v]] \\\\ \n\\operatorname*{subtree-sum}[v]&=\\operatorname*{node-sum}[v]+\\operatorname*{subtree-sum}[\\operatorname*{left}[v]]+\\operatorname*{subtree-sum}[\\operatorname*{right}[v]] \\\\ \n\\operatorname*{subtree-min}[v]&=\\min(\\operatorname*{node-min}[v],\\ \\operatorname*{subtree-min}[\\operatorname*{left}[v]],\\ \\operatorname*{subtree-min}[\\operatorname*{right}[v]]) \\\\ \n\\end{aligned}$$\nגם כאן, הזקיף $\\operatorname*{nil}[T]$ מקבל את הערך $0$ בשלושתם. בהינתן אלה, האלגוריתמים עבור הפעולות `Print-Mean(S, k)` ו-`Print-Min2(S, k)` דומים ל-`OS-Rank(S, x)` מפרק 14.1 בספר (או `Less(S, x)` מהמצגות), פרט לעובדה שהפרמטר $k$ לא חייב להיות איבר בעץ. כדי להתמודד עם בעיה זו, נשתמש באלגוריתם הסימטרי לאלגוריתם משאלה 2 למציאת \"הקודם ל-$k$\" בעץ, כלומר האיבר בעל המפתח המקסימלי שאינו גדול מ-$k$ (אלא שבניגוד לאלגוריתם שם, אם המפתח $k$ נמצא במהלך הסריקה לוקחים אותו). נתייחס אליו בהמשך פשוט כאל `Predecessor(S, k)`:\n``` {.numberLines}\nPrint-Mean(S, k)\n  pred ← Predecessor(S, k)\n  if pred = nil[S]\n    ▷ k is smaller than the minimal element in S\n    error \"no elements <= k\"\n\n  sum ← subtree-sum[left[pred]] + node-sum[pred]\n  count ← subtree-size[left[pred]] + node-size[pred]\n  while y ≠ root[S]\n    if y = right[parent[y]]\n      sum ← sum + subtree-sum[left[parent[y]]] + node-sum[parent[y]]\n      count ← count + subtree-size[left[parent[y]]] + node-size[parent[y]]\n    y ← parent[y]\n\n  return sum / count\n\nPrint-Min2(S, k)\n  pred ← Predecessor(S, k)\n  if pred = nil[S]\n    ▷ k is smaller than the minimal element in S\n    error \"no elements <= k\"\n\n  min ← Min(subtree-min[left[pred]], node-min[pred])\n  while y ≠ root[S]\n    if y = right[parent[y]]\n      min ← Min(min, subtree-min[left[parent[y]]], node-min[parent[y]])\n    y ← parent[y]\n\n  return min\n```\n\nההוכחה שהפעולות עובדות כנדרש אנלוגית להוכחה של `OS-Rank(T, x)` מהספר. בפעולה `Print-Mean` ההבדל היחיד הוא שסוכמים על שדות אחרים (ועל שני שדות במקביל), וב-`Print-Min2` לוקחים את המינימום במקום לסכום (אותו הנימוק עבור הסכום עובד גם עבור המינימום, ולמעשה עבור כל אופרטור קיבוצי). אותה שמורת לולאה מההוכחה של `OS-Rank` בספר, בשינויים המתחייבים, תקפה גם עבור שתי הפעולות כאן.\n\nבעץ $S$ יש $m_1$ איברים, ולכן בשתי הפונקציות סיבוכיות הזמן של מציאת הקודם ל-$k$ היא $O(\\log m_1)$ (כמו שראינו בשאלה 2). אם הוא נמצא, עולים במסלול ממנו חזרה לשורש (שאורכו $2\\log (k+1)$ לכל היותר, לפי למה 13.1), ולכל צומת במסלול מבצעים איטרציה של $O(1)$, לכן גם הסיבוכיות של החלק השני היא $O(\\log m_1)$, ויחד נקבל שסיבוכיות הזמן של שתי הפעולות היא $O(\\log m_1)$, כנדרש. סיבוכיות המקום בשתיהן היא $O(1)$. $\\square$\n\n"
}