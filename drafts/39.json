{
  "id": "39",
  "name": "מנמ\"א ממ\"ן 14",
  "body": "## שאלה 1\n$S$ סדרה של $n$ מספרים שלמים בקטע $[n+1,...,n+p]$\n\n### סעיף א'\nנדרש לכתוב אלגוריתם שמוצא מספר ב-$S$ עם שכיחות מקסימלית:\n``` {.numberLines}\nMode(S, n, p)\n  # Build array of frequencies\n  Create array C[n+1..n+p]\n  for i ← n+1 to n+p\n    C[i] ← 0\n\n  for i ← 1 to n\n    val ← S[i]\n    C[val] ← C[val] + 1\n\n  # Find the arg-max in C\n  max-index ← n\n  max-val ← 0\n  for i ← n+1 to n+p\n    val ← C[i]\n    if val > max-val\n      max-index ← i\n      max-val ← val\n\n  return max-index\n```\n\n**נכונות**: בדומה למיון מנייה, בתום לולאת ה-for השנייה המערך $C$ יכיל את מספרי ההופעות של כל הערכים האפשריים $n+1,...,n+p$ ב-$S$; אינדקס במערך זה שבו מתקבל ערך מקסימלי הוא איבר עם שכיחות מקסימלית ב-$S$, וזה בדיוק מה שהלולאה השלישית מוצאת, ע\"י מעבר \"נאיבי\" על כל איברי המערך (בדומה לאלגוריתם למציאת המינימום/מקסימום של מערך מתחילת פרק 9).\n**סיבוכיות זמן**: הלולאה הראשונה והשלישית מבצעות $p$ איטרציות של $\\Theta(1)$, לכן רצות בזמן $\\Theta(p)$. הלולאה השנייה מבצעת $n$ איטרציות של $\\Theta(1)$, לכן רצה בזמן $\\Theta(n)$, ויחד סיבוכיות הזמן הכוללת היא $\\Theta(n+p)$, כנדרש.\n**סיבוכיות מקום**: מלבד המערך $C$ שגודלו $p$, הפעולה משתמשת במספר קטן של משתני עזר, לכן סיבוכיות המקום היא $\\Theta(p)$. $\\square$\n\n### סעיף ב'\nנדרש לכתוב אלגוריתם שמוצא זוג איברים $a,b$ ב-$S$, לאו דווקא שונים, כך שהשכיחויות שלהם גדולות מ-$1$ והסכום $a+b$ שווה לפרמטר נתון $z$:\n``` {.numberLines}\nFrequent-Summands(S, n, p, z)\n  # Build array of frequencies\n  Create array C[n+1..n+p]\n  for i ← n+1 to n+p\n    C[i] ← 0\n\n  for i ← 1 to n\n    val ← S[i]\n    C[val] ← C[val] + 1\n\n  # Iterate over each possible a, and check the difference b=z-a\n  for a ← n+1 to n+p\n    if C[a] <= 1\n      continue  # (to the next iteration)\n    b ← z - a\n    if n+1 <= b <= n+p and C[b] > 1\n      return a, b\n\n  return NIL\n```\n\n**נכונות**: תחילה, האלגוריתם מחשב את מספרי ההופעות של כל הערכים האפשריים, בדיוק באותו האופן כמו בסעיף א'.\nכעת, זוג $a,b$ כנדרש קיים אם ורק אם יש $a\\in [n+1,...,n+p]$ שמופיע במערך יותר מפעם אחת (כלומר $C[a]>1$), כך ש-$b:=z-a$ גם הוא מופיע במערך יותר מפעם אחת; התנאי הזה בדיוק נבדק בתוכן הלולאה השלישית (מכיוון שגבולות המערך $C$ הם $[n+1..n+p]$ וההפרש $b$ עשוי לחרוג מגבולות אלה – למשל במקרה ש-$z=2(n+p)$ ו-$a=n+1$ – אנו מוסיפים בדיקה מפורשת שהוא נמצא בטווח). לכן האלגוריתם מבצע את הדרוש. \nאעיר שבמימוש אמיתי אפשר היה לחסוך איטרציות מיותרות ע\"י חישוב גבולות הלולאה השלישית באופן מתוחכם יותר – למשל, כש-$z=2(n+p)$ הערך היחיד האפשרי עבור $a$ (וגם עבור $b$) הוא $n+p$, וכש-$z$ לא נמצא בטווח $[2(n+1),2(n+p)]$ בכלל לא יכול להיות זוג $a,b$ שמקיים את הנדרש. עם זאת, חיסכון האיטרציות לא היה משפר את הפתרון בסדר גודל אסימפטוטי במקרה הגרוע והוכחת הנכונות שלו דורשת נימוק מעמיק יותר, ולכן ויתרתי עליו כאן.\n**סיבוכיות זמן**: כמו בסעיף א', אתחול המערך $C$ אורך $\\Theta(p)$, וספירת השכיחויות אורכת $\\Theta(n)$. הלולאה השלישית מבצעת $p$ איטרציות של $\\Theta(1)$, לכן אורכת $\\Theta(p)$, וביחד נקבל סיבוכיות זמן של $\\Theta(n+p)$.\n**סיבוכיות מקום**: המערך $C$ דורש מקום של $\\Theta(p)$, ומלבדו מוגדרים רק כמה משתני עזר, לכן סיבוכיות המקום היא $\\Theta(p)$. $\\square$\n\n### סעיף ג'\nנדרש לחזור על סעיפים א' וב', כשהפעם נדרשת תוחלת זמן ריצה של $O(n)$. נקבל אותה אם נחליף את המערך $C$ בטבלת גיבוב $T$ בגודל $n$, עם פונקציית גיבוב $h$ שנותנת גיבוב אחיד ופשוט מ-$[n+1,...,n+p]$ אל $[1,...,n]$, ופתרון התנגשויות בעזרת שרשור:\n``` {.numberLines}\nMode-Hash(S, n, p)\n  # Create the table of frequencies T\n  Create hash table T[1..n]\n  for i ← 1 to n\n    num ← S[i]\n    freq ← Search(T, num)\n    if freq = NIL\n      freq ← 0\n    Insert(T, num, freq + 1) \n\n  # Find the arg-max in T \n  max-num ← n\n  max-freq ← 0\n  for i ← 1 to n\n    num ← S[i]\n    freq ← Search(T, num)\n    if freq > max-freq\n      max-num ← num\n      max-freq ← freq\n\n  return max-num\n```\n\nהפעולות `Search` ו-`Insert` פועלות על טבלת גיבוב כמו בספר, כש-`Insert` מקבלת את הטבלה, מפתח ואת הערך להכניס עבורו, ו-`Search` מקבלת את הטבלה ואת המפתח לחפש (אם הערך לא נמצא, ההנחה היא ש-`Search` מחזירה `NIL`).\n\n**נכונות**: בלולאה הראשונה אנחנו בונים את טבלת מספרי ההופעות $T$ (בדומה לבניית המערך $C$ מהסעיפים הקודמים): אנו משתמשים באיברי $S$ כמפתחות, ולכל איבר מתאימים את מספר ההופעות שלו במערך – ביתר פירוט, באיטרציה ה-$i$ שולפים את מספר ההופעות של האיבר $S[i]$ (או $0$ אם הוא לא נסרק עדיין) ומגדילים אותו באחד.\nבפרט, במהלך הלולאה עוברים על כל איברי $S$ – כלומר בסופה לכל $i$, $S[i]$ מופיע כמפתח ב-$T$ – ולכן חיפוש בטבלה של איבר מ-$S$ כמפתח (כמו שעושים, למשל, בלולאה השנייה) בהכרח יצליח, ולא יוחזר `NIL`.\n\nבהינתן הטבלה הבנויה $T$ של מספרי ההופעות, אנחנו מחפשים בה אינדקס שעבורו מתקבל ערך מקסימלי, ממש כמו שעשינו בסעיף א' (ההבדל היחיד הוא שבמקום לחפש ע\"י $C[\\operatorname*{num}]$ אנחנו מחפשים ע\"י $\\operatorname*{Search}(T, \\operatorname*{num})$). לכן האלגוריתם פועל כנדרש.\n\n**סיבוכיות זמן**: כעת, אנחנו מעוניינים בתוחלת זמן הריצה להבדיל מזמן הריצה במקרה הגרוע. \nתחילה, $T$ מאותחלת עם $n$ תאים, ולאורך כל הריצה יש בה לכל היותר $n$ איברים, לכן מקדם העומס $\\alpha$ קטן או שווה ל-$1$ לאורך כל הריצה; מכך נובע שתוחלת זמן החיפוש, בין אם הוא מצליח או נכשל, היא $\\Theta(1+\\alpha)=\\Theta(1)$ (לפי משפטים 11.1 ו-11.2 בספר). בנוסף, הכנסת איבר מתבצעת בזמן $\\Theta(1)$. מכך נובע שתוחלת זמן הריצה של כל איטרציה בלולאה הראשונה היא $\\Theta(1)$ (מלבד החיפוש, כל הפעולות אורכות $O(1)$), ומלינאריות התוחלת נקבל שתוחלת זמן הריצה של הלולאה הראשונה היא $\\Theta(n)$.\nגם הלולאה השנייה מבצעת $n$ איטרציות, ותוחלת זמן הריצה של כל אחת היא $\\Theta(1)$, לכן תוחלת זמן הריצה הכולל היא $\\Theta(n)$.\n**סיבוכיות מקום**: טבלת הגיבוב תופסת מקום $\\Theta(n)$, וחוץ ממנה משתמשים רק בכמה משתנים בודדים, לכן סיבוכיות המקום היא $\\Theta(n)$.\n\nבאשר לאלגוריתם השני:\n\n``` {.numberLines}\nFrequent-Summands-Hash(S, n, p, z)\n  # Create the table of frequencies T\n  Create hash table T[1..n]\n  for i ← 1 to n\n    num ← S[i]\n    freq ← Search(T, num)\n    if freq = NIL\n      freq ← 0\n    Insert(T, num, freq + 1)\n\n  # Iterate over each possible a, and check the difference b=z-a\n  for i ← 1 to n\n    a ← S[i]\n    if Search(T, a) <= 1\n      continue  # (to the next iteration)\n    b ← z - a\n    if n+1 <= b <= n+p and Search(T, b) > 1\n      return a, b\n\n  return NIL\n```\n**נכונות**: ההבדל בין האלגוריתם כאן לאלגוריתם מסעיף ב' זהה במהותו להבדל בין האלגוריתם הקודם לזה מסעיף א' – במקום לבנות את המערך $C$ אנחנו בונים בלולאה הראשונה טבלת גיבוב $T$ של מספרי ההופעות של האיברים ב-$S$. אחר כך, בלולאה השנייה שוב עוברים על כל איבר $a$ ב-$S$, וכמו בסעיף ב' בודקים האם הוא מופיע יותר מפעם אחת (כעת בעזרת טבלת הגיבוב) והאם גם המשלים שלו $b:=z-a$ מופיע יותר מפעם אחת. לכן האלגוריתם פועל כנדרש.\n**סיבוכיות זמן**: כמו באלגוריתם הקודם, תוחלת זמן הריצה של הלולאה הראשונה היא $\\Theta(n)$. גם כאן, הלולאה השנייה מבצעת $n$ איטרציות שלכל אחת תוחלת זמן ריצה של $\\Theta(1)$, ולכן תוחלת זמן הריצה הכולל היא $\\Theta(n)$.\n**סיבוכיות מקום**: כמו באלגוריתם הקודם, סיבוכיות המקום היא $\\Theta(n)$. $\\square$\n\n\\newpage\n\n## שאלה 2\n### סעיף א'\nהבעיה העקרונית באלגוריתם הנתון היא שהוא מניח שפונקציית הגיבוב $h$ היא מונוטונית: תנאי הכרחי ומספיק לנכונות האלגוריתם היא שכשנשרשר את התאים $T[0],...,T[m-1]$ אחד לשני נקבל מערך ממוין, או באופן שקול שבהינתן $i\\lt j$, כל האיברים בתא $T[j]$ גדולים מכל האיברים בתא $T[i]$. החלוקה לתאים נעשית לפי הערך של פונקציית הגיבוב $h$, כלומר התנאי האמור שקול לכך שלכל $x,y$ כך ש-$h(x)=i,h(y)=j$, בהכרח $x\\lt y$; תנאי זה בתורו שקול לכך ש-$x\\ge y$ גורר ש-$h(x)\\ge h(y)$, כלומר ש-$h$ מונוטונית.\nאבל, ההנחות על טבלת הגיבוב כלליות מדי מכדי להבטיח מונוטוניות: כדוגמה קונקרטית ניקח את $U$ להיות תחום המספרים הטבעיים, $h(x)=x\\bmod m$ ונניח שמכניסים לטבלה את $n=m+1$ המספרים $0,1,...,m$: אז $h(0)=h(m)=0$, לכן בתא ה-$0$ יהיו זוג האיברים $\\set{0,m}$, ולכל $i$ אחר בתא ה-$i$ יהיה רק $\\set{i}$. בתום המיון נקבל את המערך $[0,m,1,2,...,m-1]$ – והמיון כשל. כאמור, שורש הבעיה הוא ש-$h$ לא מונוטונית, ובמקרה הקיצוני הנתון האיבר הגדול ביותר הוכנס לתא הקטן ביותר. $\\square$\n\n### סעיף ב'\nנדרש לנתח את תוחלת זמן הריצה של האלגוריתם כפונקציה של $m$ ו-$n$, וכן את זמן הריצה במקרה הגרוע. נפרק את זמן הריצה לפי השלבים:\n1. הכנסה לטבלת גיבוב רצה בזמן $\\Theta(1)$ תמיד, לכן הצעד הראשון (שבו $n$ האיברים מוכנסים לטבלה) אורך $\\Theta(n)$.\n2. הגיבוב הוא אחיד ופשוט, ולכן תוחלת מספר האיברים שנמצאים בכל תא אחרי השלב הראשון היא $n/m$. יתר על כן, בשל העובדה שהאיברים בלתי תלויים זה בזה ושווי התפלגות, התפלגות האיברים שנמצאים בכל תא אחרי ההכנסה היא אחידה, במובן הבא: בהינתן שיש בתא כלשהו $k$ איברים, לכל יחסי הסדר האפשריים ביניהם יש אותה הסתברות להופיע (אם היינו מניחים שאלו איברים שונים, הכוונה הייתה שלכל התמורות שלהם אותה הסתברות להופיע, אלא שייתכנו חזרות ולכן אלה לא בדיוק תמורות). הנחה זו מאפשרת לנו להשתמש בתוצאות מהספר על ביצועי המיון המהיר במקרה הממוצע – דהיינו, תוחלת זמן הריצה של המיון של תא מסוים, בהינתן שיש בו $k$ איברים, היא $\\Theta(k\\log k)$. \nכעת נפריד למקרים: כש-$n=m$, תוחלת מספר האיברים בתא היא $n/m=1$, ולכן תוחלת זמן הריצה של המיון המהיר של תא אחד היא $\\Theta(1)$; יש $m$ תאים, ולכן השלב לוקח $\\Theta(m)$ צעדים בממוצע.\nכש-$n\\gt m$, תוחלת מספר האיברים בכל תא היא $n/m\\gt 1$, ולכן תוחלת זמן הריצה של מיון מהיר בתא אחד היא $(n/m)\\log(n/m)$; מלינאריות התוחלת נקבל שתוחלת זמן הריצה של השלב כולו היא $\\Theta(n\\log(n/m))$. \n3. אנחנו מניחים שהרשימות המקושרות שנמצאות בכל תא הן דו-כיווניות, ולכן שרשור של שתי רשימות אורך $\\Theta(1)$ (שכן צריך רק להוסיף את ראש הרשימה השנייה אחרי הזנב של הראשונה). יש $m$ רשימות סה\"כ, לכן שרשור כל הרשימות אורך $\\Theta(m)$. לחילופין, אפשר גם להעתיק את הרשימות המקושרות בזו אחר זו לתוך מערך (המערך המקורי או אחד חדש), ובשל העובדה שיש $n$ איברים זה אורך $\\Theta(n)$. אבל כמו שראינו הצעד הראשון ממילא לוקח $\\Theta(n)$ ו-$n\\ge m$, לכן זה לא משנה את זמן הריצה האסימפטוטמי של האלגוריתם.\n\nיחד נקבל שתוחלת זמן הריצה של האלגוריתם היא\n$$\\begin{cases}\n\\Theta(n) & n=m \\\\\n\\Theta(n\\log(n/m)) & n\\gt m\n\\end{cases}$$\nבמקרה הגרוע ביותר, כל האיברים ברשימה מוכנסים לאותו תא בטבלת הגיבוב, וגם הדגימות האקראיות שמתבצעות במהלך המיון המהיר מניבות את הביצועים הגרועים ביותר. זמן הריצה של ההכנסה ושל השרשור לא משתנים במקרה הזה, אבל המיון המהיר ייקח $\\Theta(n^2)$ בתא שבו נמצאים כל האיברים (ו-$\\Theta(1)$ בכל שאר התאים, שהם ריקים), לכן סיבוכיות הזמן במקרה הגרוע היא $\\Theta(n^2)$. $\\square$\n\n### סעיף ג'\nנתון ש-$n$ המספרים מתפלגים באופן אחיד בתחום $U=[0,...,n^3-1]$, ונדרש למצוא פונקציית גיבוב $h$ וערך ל-$m$ שעבורו האלגוריתם הנתון יהיה אלגוריתם מיון תקין, עם תוחלת זמן ריצה $O(n)$.\nניקח $m=n$ ואת פונקציית הגיבוב\n$$h(x):=\\floor{\\frac{x}{n^2}}$$\nהתחום הנתון $U$ הוא בדיוק אוסף המספרים $x$ שעבורם $0\\le h(x)\\lt n$, ולכן $h$ מתאימה לערך שבחרנו עבור $m$. בנוסף, \n$$h^{-1}(a)=[an^2,...,(a+1)n^2-1]$$\nובפרט $\\left|h^{-1}(a)\\right|=n^2=n^3/n$, כלומר מספר הערכים שיוכנסו לתא ה-$a$ זהה עבור כל $0\\le a\\lt n$; יחד עם ההנחה שהמספרים מתפלגים באופן אחיד ב-$U$, נקבל ש-$h$ אכן נותנת גיבוב אחיד ופשוט מ-$U$ ל-$[0,...,n-1]$. בנוסף, $h$ מונוטונית עולה, ומסעיף א' זה תנאי הכרחי ומספיק לנכונות האלגוריתם, כלומר הוא אכן ימיין בהצלחה. לבסוף, כאן $m=n$, ומהאמור בסעיף הקודם תוחלת זמן הריצה של האלגוריתם היא $\\Theta(n)$, כנדרש.\nאין באמור בסעיף זה סתירה לאמור בסעיף א' – שם ראינו שההנחות על טבלת הגיבוב כלליות מדי מכדי להבטיח את המונוטיות של פונקציית הגיבוב $h$ באופן כללי, אבל זה כמובן לא אומר שבמקרים ספציפיים, כמו המקרה הנתון פה, לא נוכל למצוא פונקציית גיבוב מונוטונית מתאימה. $\\square$\n\n\\newpage\n\n## שאלה 3\nנסמן את קיבולות הכדים האדומים ב-$a_1,...,a_n$, ואת הכחולים ב-$b_1,...,b_n$, בהתאמה.\nפעולת ההשוואה הנתונה מאפשרת להשוות בין הקיבולות של כל זוג $a_i,b_j$, אבל לא בין שני כדים אדומים או שני כחולים.\nנשים לב שההנחות על הכדים אומרות ש-$(b_1,...,b_j)$ מתקבלת באופן יחיד כתמורה של $(a_1,...,a_n)$, שכן לכל $a_i$ מתאים $b_j$ יחיד (והקיבולות של כל הכדים האדומים, או באופן שקול של כל הכחולים, שונות זו מזו).\nהאלגוריתם הרצוי נדרש, בעצם, למצוא את התמורה הזו (ההתאמה בין כל כד אדום לכד הכחול המתאים).\n\n### סעיף א'\nנדרש אלגוריתם דטרמינסיטי שמוצא את הזיווג הנדרש בעזרת $\\Theta(n^2)$ השוואות. אפשר לממש אלגוריתם כזה באופן \"ראש בקיר\" (brute force):\n``` {.numerLines}\nMatch-Naive(A,B)\n  for i ← 1 to n\n    for j ← 1 to n\n      if A[i] = B[j]\n        output (i,j)\n```\n\n(הערה: האלגוריתם מניח שקיבולות הכדים שמורות במערכים $A,B$ (שאורכם $n$), כך ש-$A[i]=a_i,B[j]=b_j$. בנוסף, הכוונה ב-output היא להכריז על הזוג כמתאים, במימוש אפשר היה למשל לאסוף את כל הזוגות למערך ולהחזיר אותו אך זה פחות מהותי רעיונית).\nמההנחות על הכדים, לכל $1\\le i\\le n$ יש אינדקס $1\\le j(i)\\le n$ יחיד כך ש-$a_i=b_{j(i)}$ – האלגוריתם מוצא אותו ע\"י סריקת כל האיברים במערך $B$ עד שהוא מגיע אליו.\n\nבאשר למספר ההשוואות, נשים לב שבגלל שכל תמורה היא הפיכה, לכל $1\\le j\\le n$ יש $i$ יחיד שמתאים לו, ולכן לכל $1\\le j\\le n$ תהיה איטרציה של הלולאה החיצונית שבה הלולאה הפנימית תבצע $j$ איטרציות בדיוק. כל איטרציה של הלולאה הפנימית מבצעת השוואה יחידה, ולכן מספר ההשוואות הכולל הוא\n$$\\sum_{j=1}^n{j}=\\frac{n(n+1)}{2}=\\Theta(n^2)$$\nמשיקולים דומים, סיבוכיות הזמן של האלגוריתם היא $\\Theta(n^2)$. סיבוכיות המקום של האלגוריתם היא $\\Theta(1)$. $\\square$\n\n### סעיף ב'\nנדרש להוכיח חסם תחתון של $\\Omega(n\\log n)$ על מספר ההשוואות שאלגוריתם כנדרש חייב לבצע.\n\nההוכחה דומה מאוד להוכחה שאלגוריתם מיון השוואתי חייב לבצע לפחות $\\Omega(n\\log n)$ השוואות: נבנה עץ החלטה שמתאר את ריצת האלגוריתם על קלט בגודל $n$. בדומה לאלגוריתם מיון, מטרת האלגוריתם כאן היא למצוא תמורה, ולכן העלים יכילו תמורות על $n$ איברים. אלא שכאן, בניגוד לאלגוריתם מיון, התמורה מתאימה בין שני מערכים נתונים שונים (להבדל ממערך והתמורה הממוינת שלו), ולכן כאן הצמתים הפנימיים יכילו זוגות $i:j$, כש-$i,j\\in \\set{1,...,n}$ לאו דווקא שונים, ובו מתבצעת השוואה בין $a_i,b_j$ (ולכל צומת כזה יהיו שני בנים, המתאימים למקרים ש-$a_i\\le b_j,a_i\\gt b_j$).\nכל אלגוריתם נכון, כלומר שאכן פותר את בעיית הזיווג, חייב להיות מסוגל להבחין בין $n!$ התמורות האפשריות, ולכן כל אחת מהן חייבת להופיע בעלה (ויותר מכך, עלה זה חייב להיות נגיש, כלומר המסלול מהשורש אליו חייב לייצג ריצה אפשרית אמיתית של האלגוריתם).\nכעת, נסמן ב-$h$ את גובה העץ; כמו במקרה של מיון השוואה, גודל זה מתאר את מספר ההשוואות המירבי שהאלגוריתם עשוי לבצע עבור קלט באורך $n$ (כלומר את המקרה הגרוע). עץ בינארי בגובה $h$ מכיל לכל היותר $2^h$ עלים, לכן\n$$2^h\\ge n!\\implies h\\ge\\log(n!)=\\Omega(n\\log n)$$\nכנדרש. $\\square$\n\n### סעיף ג'\nנדרש אלגוריתם אקראי שתוחלת מספר ההשוואות בו היא $O(n\\log n)$. \nהאלגוריתם שלהלן שואב השראה ממיון מהיר: נבחר כד אדום $x:=a_i$ באקראי כאיבר הציר, ונחלק את המערך $B$ לשתי פרוסות – של האיברים שקטנים מ-$x$ ואלה שגדולים ממנו – בעזרת וריאציה של האלגוריתם `Partition` מאלגוריתם המיון המהיר. \nאנחנו מניחים שהגרסה של `Partition` שמופיעה כאן מקבלת כארגומנטים איבר ציר ופרוסה מתוך מערך (כלומר את המערך ואינדקסי התחלה וסוף), ושניתן להשוות בין איבר הציר לאיברי הפרוסה, למשל איבר ציר מתוך המערך $A$ ואת המערך $B$ או להפך. אין בכך קושי מהותי, שכן כל ההשוואות במימוש הרגיל של `Partition` מתבצעות ממילא בין איבר הציר ואיברים של המערך. \n\nבתום החלוקה, נקבל שני תת-מערכים $B[1..q-1],B[q+1..n]$, כש-$B[q]=x=a_i$. אחר כך נחלק גם את המערך $A$ בהתאם לערך $x=B[q]$ – בשל ההתאמה החד-חד-ערכית בין קיבולות הכדים האדומים והכחולים, בתום החלוקה נקבל את אותו האינדקס $q$, כלומר יתקיים $B[q]=A[q]=x$, והפרוסות $A[1..q-1],A[q+1..n]$ יכילו את האיברים שקטנים או גדולים מ-$x$, בהתאמה. כעת תנאי הבעיה מתקיימים עבור כל אחד מהזוגות $A[1..q-1],B[1..q-1]$ ו-$A[q+1..n],B[q+1..n]$ בנפרד, וקריאה רקורסיבית לאלגוריתם עבורן תשלים את הזיווג.\n``` {.numberLines}\nMatch(A, B, p, r):\n  if r >= p\n    i ← Random(p, r)\n    q ← Partition(B, p, r, A[i])\n    Partition(A, p, r, B[q]) # also returns q\n\n    Match(A, B, p, q-1)\n    Match(A, B, q+1, r)\n```\n\n(הערה: בסוף הריצה המערכים $A,B$ יכילו את הזוגות המזווגים, כלומר יתקיים $A[k]=B[k]$ לכל $k$. לכן, אין צורך \"לפלוט\" את הזוגות כמו באלגוריתם מסעיף א')\nהקריאה החיצונית לאלגוריתם היא:\n``` {.numberLines}\nMatch(A, B)\n  n ← length[A] # equal to length[B], by assumption\n  Match(A, B, 1, n)\n```\n\nנשים לב שכל ההשוואות בין הכדים מתבצעות בתוך `Partition`. הניתוח שלה כאן דומה למקרה של מיון מהיר:\nנרשום ב-$z_1\\lt z_2\\lt ...\\lt z_n$ את קיבולות הכדים $\\set{a_1,...,a_n}=\\set{b_1,...,b_n}$, בסדר עולה, וכן $Z_{ij}=\\set{z_i,...,z_j}$ (כאן $i\\le j$, בניגוד למיון מהיר שבו $i,j$ בהכרח שונים).\nתחילה, נשים לב שבכל קריאה ל-`Match`, הערך שנבחר באקראי משמש כציר בשתי החלוקות, במובן שלכדים שמשמשים באיברי הציר בחלוקה של $B$ ואז בזו של $A$ אותה קיבולת. השוואות מתבצעות רק בין איבר ציר לאיבר מהמערך השני, ואחרי שערך מסוים נבחר כציר בקריאה אחת ל-`Match`, הוא לא יופיע באף אחת מהקריאות הבאות (כי הוא לא נכלל באף אחת משני זוגות הפרוסות שנוצרים בחלוקה). לכן, אם מתבצעת בשלב מסוים השוואה בין $z_i,z_j$, אז היא מתבצעת פעמיים באותה קריאה ולא מתבצעת שוב אחר כך. בניסוח אחר, השוואה נתונה מתבצעת פעמיים בדיוק או אפס פעמים.\nלכל $i\\le j$ נסמן ב-$C_{ij}$ את המאורע שנערכת השוואה בין $z_i$ ו-$z_j$, וכן $X_{ij}:=1_{C_{ij}}$. עבור $i=j$, מתקיים $\\PP(C_{ij})=1$, שכן בהכרח מתבצעת השוואה בין איבר הציר שנבחר לכד בצבע האחר עם אותה קיבולת. \nעבור $i\\lt j$, מאותו שיקול שבספר, מתקיימת השוואה בין $z_i,z_j$ אם ורק אם אחד מהם הוא האיבר הראשון שנבחר כציר מתוך $Z_{ij}$; תחת ההנחה שהבחירות אקראיות ובלתי תלויות זו בזו, מתקיים\n$$\\PP(C_{ij})=\\frac{2}{j-i+1}$$\nכעת, נסמן ב-$X$ את מספר ההשוואות הכולל שהאלגוריתם מבצע במהלך הריצה. בין כל זוג איברים $z_i,z_j$, $i\\le j$, מתקיימות $2X_{ij}$ השוואות (כי כאמור אם יש השוואה אחת לפחות אז יש בדיוק שתיים), לכן\n$$X=\\sum_{1\\le i\\le j\\le n}2X_{ij}=2\\sum_{i=1}^{n}\\sum_{j=i}^nX_{ij}$$\nולכן\n$$\\begin{aligned}\n\\EE(X)&=2\\sum_{i=1}^{n}\\sum_{j=i}^n\\EE(X_{ij})=2\\sum_{i=1}^{n}\\sum_{j=i}^n\\PP(C_{ij}) \\\\\n&=2\\sum_{i=1}^n\\PP(C_{ii})+2\\sum_{i=1}^{n-1}\\sum_{j=i+1}^n{\\PP(C_{ij})} \\\\\n&=2n+2\\sum_{i=1}^{n-1}\\sum_{j=i+1}^n{\\frac{2}{j-i+1}}=O(n)+O(n\\log n)\n\\end{aligned}$$\nכשהשוויון הראשון נובע מלינאריות התוחלת, והאחרון מניתוח המיון המהיר בספר (שם מראים שהמחובר השני הוא $O(n\\log n)$). סה\"כ קיבלנו ש-$\\EE(X)=O(n\\log n)$, כנדרש. \n\nבמקרה הגרוע, הדגימות האקראיות כולן מובילות לחלוקות לא מאוזנות, שבהן פרוסה אחת ריקה ופרוסה אחת מכילה את כל האיברים פרט לאיבר הציר. החלוקה בכל מקרה דורשת $\\Theta(n)$ השוואות, ולכן במקרה הזה, כמו במיון מהיר מתקבלת נוסחת הנסיגה\n$$T(n)=T(n-1)+\\Theta(n)$$\nשפתרונה הוא $T(n)=\\Theta(n^2)$. $\\square$\n\n\\newpage\n\n## שאלה 4\nנכנה את מבנה הנתונים הנדרש בפשטות \"טבלת ציונים\" – `Grade-Table`. \nתחילה, את האיבר השכיח ביותר בטבלה אפשר למצוא בזמן לינארי (ביחס לגודל הטבלה, כלומר $O(nm)$) אם נבנה מערך $C[0..100]$ של מספר ההופעות של כל ציון בטבלה, כמו במיון מנייה, ונחפש בו את האיבר המקסימלי באופן הסטנדרטי, ע\"י מעבר על כל האיברים. בשל העובדה שהמבנה סטטי, אפשר לבצע את כל העבודה הזו כשבונים את מבנה הנתונים, ולשמור בו רק את התוצאה.\nבנוסף, נשים לב שפעולות החזרת הממוצע של סטודנט מסוים בכל הקורסים, או של כל הסטודנטים בקורס מסוים, מתקבלות כמקרה פרטי של פעולת החזרת הממוצע בחתך כלשהו בטבלה (כשהחתך הוא עמודה יחידה או שורה יחידה, בהתאמה). כדי לממש את הפעולה הזו בזמן $O(1)$, אפשר להשתמש בעיקרון הבא: בהינתן חתך $(r_1,c_1,r_2,c_2)$, ממוצע הערכים בו הוא סכום כל הערכים בחתך חלקי מספר האיברים בו, שהוא $(r_2-r_1+1)(c_2-c_1+1)$. לכן, חישוב הממוצע בחתך בזמן $O(1)$ שקול לחישוב הסכום בו בזמן $O(1)$. \nכדי לחשב את הסכומים מתוך טבלה $A$ נבנה טבלה נוספת $T$, כך שהאיבר $T[r,c]$ יכיל את סכום החתך $(1,1,r,c)$; כפי שנראה להלן, לא קשה לעשות זאת בזמן $O(nm)$. בהינתן חתך כללי $(r_1,c_1,r_2,c_2)$, נשתמש בפירוק\n$$(1,1,r_2,c_2)=(1,1,r_1-1,c_2)\\cup (1,1,r_2,c_1-1)\\cup (r_1,c_1,r_2,c_2)$$\n (אנחנו מזהים כאן את הקואורדינטות שמייצגות את החתך עם קבוצת האיברים שנמצאת בחתך הזה).\n החיתוך של שני החתכים הראשונים משמאל הוא $(1,1,r_1-1,c_1-1)$, ושניהם זרים לחתך השלישי. ולכן נקבל את הנוסחה\n$$\\sum_{(i,j)\\in (r_1,c_1,r_2,c_2)}A[i,j]=T[r_2,c_2]-T[r_1-1,c_2]-T[r_2,c_1-1]+T[r_1-1,c_1-1]$$\nולכן בהינתן הטבלה $T$, חישוב הסכום (ולכן גם הממוצע) בכל חתך מתקבל בזמן $O(1)$.\n\nכעת נתאר את מבנה הנתונים באופן מפורש: מימוש מבנה הנתונים `Grade-Table` מתבצע בעזרת טבלה $T$ בגודל $n\\times m$ (כלומר, גודלה זהה לגודל הטבלה $A$ שממנה נבנה מבנה הנתונים). השדה $\\operatorname*{width}[T]=m$ מתאר את רוחב הטבלה, או לחילופין את מספר הסטודנטים, והשדה $\\operatorname*{height}[T]=n$ מתאר את גובהה, או לחילופין את מספר הקורסים. בנוסף, יש לטבלה שדה $\\operatorname*{mode}[T]$ שמצביע על הציון השכיח ביותר בטבלה $A$.\n\nהפעולה `Build-Grade-Table(A)` בונה את טבלת הציונים מתוך טבלה נתונה $A$ שעונה על הדרישות בשאלה. אנחנו מניחים שהפעולה `Copy(A)` מקבלת טבלה ומחזירה עותק שלה, עם אותם ממדים ואותם ערכים; אם אין צורך לשמור על הטבלה $A$, כלומר מותר \"להרוס\" אותה, אז אין צורך בפעולה זו, ואפשר לבצע את כל הפעולות על $A$ ישירות (אלא שאז צריך למצוא את הציון השכיח ביותר לפני שמשנים את הטבלה, כלומר החלק השני בפעולה צריך להופיע לפני הראשון)\n``` {.numberLines}\nBuild-Grade-Table(A)\n  # Build the sum table T\n  T ← Copy(A)\n  for i ← 1 to height[T]\n    for j ← 2 to width[T]\n      T[i,j] ← T[i,j] + T[i,j-1]\n\n  for i ← 2 to height[T]\n    for j ← 1 to width[T]\n      T[i,j] ← T[i,j] + T[i-1, j]\n\n  # Find the mode\n  Create array C[0..100]\n  for i ← 1 to height[A]\n    for j ← 1 to width[A]\n      grade ← A[i,j]\n      C[grade] ← C[grade] + 1\n\n  # C[i] now contains the amount of occurences of the grade i.\n  mode[T] ← Maximum(C)\n\n  return T\n```\nאת מציאת הציון השכיח ביותר הסברנו לעיל, לכן נתמקד בבניית הטבלה. \nנסמן ב-$T_0=A$ את ערכי הטבלה $T$ לפני הלולאה הראשונה, ב-$T_1$ אחרי הלולאה הראשונה וב-$T_2$ אחרי הלולאה השנייה (כלומר בסוף הריצה). באינדוקציה פשוטה נקבל שבתום הריצה הראשונה כל איבר ב-$T$ מכיל את סכום כל האיברים שהופיעו מתחילת השורה שלו עד אליו (כולל), כלומר\n$$T_1[r,c]=T_0[r,1]+...+T_0[r,c]=A[r,1]+...+A[r,c]$$\nבאופן דומה, בתום הריצה השנייה כל איבר ב-$T$ מכיל את סכום כל האיברים שהופיעו מתחילת העמודה שלו עד אליו, כלומר\n$$T_2[r,c]=T_1[1,c]+...+T_1[r,c]$$\nיחד נקבל\n$$T_2[r,c]=\\sum_{i=1}^rT_1[i,c]=\\sum_{i=1}^r\\sum_{j=1}^cA[i,j]$$\nכנדרש.\n\nבאשר לסיבוכיות הזמן של הפעולה, שלוש הלולאות רצות בזמן $\\Theta(mn)$, שכן כל איטרציה בכל אחת מהן היא $\\Theta(1)$ והן מבצעות $m(n-1),(m-1)n$ ו-$mn$ איטרציות בהתאמה. גם ההעתקה, אם לא דורסים את הטבלה המקורית $A$, רצה בזמן $\\Theta(mn)$. למערך $C[0..100]$ אורך קבוע, לכן מציאת המקסימום בו אורכת $\\Theta(1)$, ויחד נקבל שבניית הטבלה אורכת $\\Theta(mn)$, כנדרש. \nמלבד משתני עזר ספורים, הפעולה משתמשת בטבלה החדשה $T$, אם אכן מעתיקים את $A$, ובמערך השכיחויות $C$. ל-$C$ סיבוכיות מקום $\\Theta(1)$ כי אורכו קבוע, ולכן סיבוכיות המקום של הפעולה – ושל מבנה הנתונים בכלל – היא $\\Theta(nm)$ אם מעתיקים את הטבלה $A$, ו-$\\Theta(1)$ אם דורסים אותה.\n\nהפעולה `Most-Frequent-Grade(T)` מחזירה את הציון הנפוץ ביותר בטבלה:\n``` {.numberLines}\nMost-Frequent-Grade(T)\n  return mode[T]\n```\n\nלחילופין, אפשר היה פשוט לגשת ל-$\\operatorname*{mode}[T]$ ישירות. סיבוכיות הזמן והמקום של הפעולה הן $\\Theta(1)$.\n\nהפעולה `Slice-Average(T, r1,c1,r2,c2)` מחזירה את הממוצע לאורך חתך כלשהו בטבלה; הפעולות \n`Student-Average(T, j)` ו-`Course-Average(T, i)` מחזירות את ממוצע הציונים של סטודנט מסוים (באינדקס $j$) או של קורס מסוים (באינדקס $i$):\n``` {.numberLines}\nSlice-Average(T,r1,c1,r2,c2)\n  sum ← T[r2,c2]-T[r1-1,c2]-T[r2,c1-1]+T[r1-1,c1-1]\n  quant ← (r2-r1+1)(c2-c1+1)\n  return sum / quant\n\nStudent-Average(T,j)\n  return Slice-Average(T, 1, j, height[T], j)\n\nCourse-Average(T, i)\n  return Slice-Average(T, i, 1, i, width[T])\n```\nסיבוכיות הזמן והמקום של שלושתן היא $\\Theta(1)$. $\\square$\n\n"
}