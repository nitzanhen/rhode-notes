{
  "id": "29",
  "name": "מנמ\"א ממ\"ן 12 שאלה 1",
  "body": "---\nheader-includes:  \\setmonofont{Courier New}\n---\nמצטער על האיחור!\n\n## שאלה 1\n### סעיף א'\n$A$ ערימת מינימום עם $n$ איברים שונים.\nאת האלגוריתם הנדרש `IncreaseKey(i, val)` אפשר לממש באופן הבא:\n``` {.numberLines}\nIncreaseKey(i, val)\n  A[i] ← val\n  MinHeapify(A, i)\n```\n\nכש-`MinHeapify(A,i)` היא הגרסה של `MaxHeapify(A,i)` (פרק 6.2 בספר) עבור ערימת מינימום:\n``` {.numberLines}\nMinHeapify(A,i)\n  l ← Left(i)\n  r ← Right(i)\n  if l ≤ heap-size[A] and A[l] < A[i]\n    smallest ← l\n  else\n    smallest ← i\n  if r ≤ heap-size[A] and A[r] < A[smallest]\n    smallest ← r\n\n  if smallest ≠ i\n    exchange A[i] ↔ A[smallest]\n    MinHeapify(A, smallest)\n```\n\n**נכונות**: אחרי ההשמה של $\\operatorname*{val}$ במקום $A[i]$, הערימה מכילה את הערכים הנדרשים, אלא שהערך החדש עשוי להפר את מבנה הערימה. כדי לתקן את ההפרה מחליקים את הערך החדש במורד הערימה: שני הבנים של $i$ הם שורשים של עצים שמקיימים את תכונת הערימה, לכן בסוף הריצה של `MinHeapify` גם האיבר במקום ה-$i$ יהיה שורש של ערימה. האיברים שלפני $i$ לא השתנו, ולכן המערך כולו מקיים את תכונת הערימה.\n\n**סיבוכיות**: בדומה לאלגוריתם `MaxHeapify`, סיבוכיות הזמן של `MinHeapify` במקרה הגרוע היא $\\Theta(\\log n)$, או לחילופין $\\Theta(h)$ כש-$h$ זה גובה האיבר $i$ בערימה; סיבוכיות המקום היא $\\Theta(1)$. `IncreaseKey` מוסיף עליה עוד פעולת השמה אחת, ולכן גם לו יש סיבוכיות זמן $\\Theta(\\log n)$ וסיבוכיות מקום $\\Theta(1)$.\n\n### סעיף ב'\nזמן הריצה של הפסודו-קוד הנתון הוא $\\Omega(n)$ כי לולאת ה-for מבצעת $n$ איטרציות שכולן $\\Omega(1)$. לכן מספיק להראות שזמן הריצה הוא $O(n)$, והנימוק דומה מאוד לנימוק שהאלגוריתם `Build-Max-Heap(A)` מפרק 6.3 רץ בזמן לינארי:\nהגובה של ערמה עם $n$ איברים הוא $\\floor{\\log n}$, ומספר הצמתים שגובהם $h$ הוא לכל היותר $\\ceil{n/2^{h+1}}$. כפי שאמרנו בסעיף הקודם, `IncreaseKey(i, val)` רץ בזמן $O(h)$, כש-$h$ זה הגובה של $i$ בערימה. לכן זמן הריצה הכולל הוא\n$$\\sum_{h=0}^{\\floor{\\log n}}{\\ceil{\\frac{n}{2^{h+1}}}}O(h)=O\\left(n\\sum_{h=0}^{\\floor{\\log n}}\\frac{h}{2^{h+1}}\\right)=O(n)$$\nכשהמעבר האחרון נובע מכך ש-\n$$\\sum_{h=0}^{\\floor{\\log n}}\\frac{h}{2^{h+1}}\\le \\sum_{h=0}^{\\infty}\\frac{h}{2^{h+1}}=\\frac{1}{2}\\sum_{h=0}^{\\infty}\\frac{h}{2^{h}}=\\frac{1}{2}\\cdot 2=1$$\nכנדרש. \nזה לא נדרש לסיבוכיות, אבל אפשר אף לדייק יותר את ניתוח זמן הריצה אם נבחין שהבחירה של `MaxVal` בקטע הקוד מקיימת את התכונה הבאה: בתחילת האיטרציה ה-$i$ של לולאת ה-for, ערכו של המשתנה `MaxVal` גדול ממש מכל איבר בערימה (הקביעה הזו שקולה לקביעה שערכו גדול מהמקסימום של האיברים מהערימה, וזו שמורה של לולאת ה-for שבקטע). מכיוון ש-$A$ היא ערימת מינימום, אחרי הגדרת ערכו של האיבר ה-$i$, הוא יוחלק בכל איטרציה עד לתחתית העץ, כלומר יתבצעו בדיוק $h(i)$ החלקות. יחד עם החישוב שלעיל, נקבל שבמהלך ריצת קטע הקוד מתבצעות בקירוב $n$ החלקות (עבור ערכי $n$ גדולים, שבהם הסכום על $h$ מתקרב ל-$1$), כלומר החסם העליון שמצאנו הוא די הדוק (להבדיל מהחסם הראשוני שמצאנו – $n$ איטרציות של $\\Omega(1)$). $\\square$\n\n\n\n"
}