{
  "id": "33",
  "name": "מנמ\"א ממ\"ן 12 שאלה 4",
  "body": "### סעיף א'\n$A$ מערך באורך $n$ של מספרים ממשיים.\n**מ.ש.ל.** ב-$A$ יש לכל היותר שלושה מספרים שמופיעים במערך יותר מ-$\\floor{n/4}$ פעמים.\n_הוכחה._ נניח בשלילה שיש ארבעה מספרים $a_1,a_2,a_3,a_4$ שחוזרים על עצמם יותר מ-$\\floor{n/4}$ פעמים. אז כל אחד מופיע לפחות $\\floor{n/4}+1\\gt n/4$ פעמים, ומספר ההופעות הכולל של ארבעת הוא לפחות\n$$4\\left(\\floor{\\frac{n}{4}}+1\\right)\\gt 4\\left(\\frac{n}{4}\\right)=n$$\nבסתירה לכך שמספר ההופעות הכולל של כולם הוא לכל היותר מספר האיברים במערך. מהסתירה נסיק שיש לכל היותר שלושה מספרים כאלה. $\\square$\n\n### סעיף ב'\nנדרש לכתוב אלגוריתם שמוצא את כל המספרים שמופיעים במערך $A$ יותר מ-$\\floor{n/4}$ פעמים.\nרעיון האלגוריתם `FindFrequent4(A)` הוא כזה: נסמן ב-$a_1\\le a_2\\le ...\\le a_n$ את איברי המערך $A$, ממוינים. בהשראת תרגיל 9.3-6 בספר, נתבונן בשלושת הקוונטילים מסדר $4$ של קבוצת האיברים של $A$ – במקרה שלנו, $a_{\\floor{n/4}},a_{\\floor{n/2}},a_{\\floor{3n/4}}$. אם איבר $b$ מופיע במערך יותר מ-$\\floor{n/4}$ פעמים, אז יש אינדקים $i,j$ כך ש-$j\\gt i+\\floor{n/4}$ ו-$a_i=a_{i+1}=...=a_j$. אבל בגלל שהמרחק בין $i,j$ גדול יותר מהמרחק בין הקוונטילים, בהכרח אחד מהאינדקסים בין $i$ ל-$j$ שייך לאחד הקוונטילים.\nאת הערך של שלושת הקוונטילים אפשר למצוא בזמן לינארי ע\"י שלוש קריאות ל-`Select` מפרק 9.3, ועבור כל אחד אפשר לסרוק את המערך באופן \"נאיבי\", כלומר לעבור איבר-איבר ולספור את כמות ההופעות שלו:\n``` {.numberLines}\nFindFrequent4(A)\n  n ← length[A]\n  for i ← 1 to 3:\n    quant ← Select(A, floor(in/4))\n    count ← Count(A, quant)\n    if count > floor(n/4)\n      output quant\n```\n\n(הערה: ב-output הכוונה \"להכריז\" על הערך ככזה שמקיים את מה שמחפשים. במימוש אמיתי אפשר היה, נניח, ליצור רשימה או מבנה נתונים אחר ולהוסיף אותם אליו כשמוצאים, ובסוף להחזיר את הרשימה כולה, אבל זה לא מהותי לרעיון האלגוריתם).\n\nהאלגוריתם `Count(A, x)` מממש ספירה נאיבית:\n``` {.numberLines}\nCount(A, x)\n  count ← 0\n  for i ← 1 to length[A]\n    if A[i] = x\n      count ← count + 1\n  return count \n```\n\nסיבוכיות הזמן של `Select` ושל `Count` היא לינארית, ולולאת ה-for ב-`FindFrquent4` מריצה שלוש איטרציות של כל אחת סה\"כ, לכן זמן הריצה הוא אכן לינארי. \nסיבוכיות המקום היא $\\Theta(1)$. $\\square$\n\n### סעיף ג'\nנדרש אלגוריתם `FindFrequent` שמוצא את כל האיברים ב-$A$ שמופיעים יותר מ-$\\floor{n/k}$ פעמים. הרעיון הוא כזה: \nמקרה הבסיס של הרקורסיה הוא המקרה $k\\le 4$, שבו אפשר לקרוא ל-`FindFrequent4` או לגרסה מקבילה שלה עבור $k=2,3$ (במקרה $k=1$ אין איברים שנמצאים יותר מ-$n$ פעמים, לכן הפונקציה לא פולטת כלום); נניח ש-`FindFrequentBase(A,k)` מקבלת מערך וערך $k\\le 4$, ומטפלת במקרה הזה (בזמן לינארי).\n\nבמקרה הכללי, נניח ש-$b$ ערך שמופיע במערך יותר מ-$\\floor{n/k}$ פעמים; בגלל שמספר ההופעות הוא שלם, זה שקול לכך ש-$b$ מופיע במערך יותר מ-$n/k$ פעמים.\nייתכן שערך החציון מופיע יותר מ-$n/k$ פעמים, לכן נמצא את ערך החציון בעזרת `Select` ונספור נאיבית את כמות ההופעות שלו. עבור כל ערך $b$ אחר, נשים לב שהחלוקה שניתנת ע\"י `Partition`, סביב ערך החציון, תשים את כל ההופעות שלו באחת משני תתי המערכים הנוצרים (השמאלי אם $b$ קטן מהחציון, הימני אחרת). נסמן ב-$q$ את אינדקס החלוקה, אז מתקבלות שתי פרוסות $A[1..q-1],A[q+1..n]$, שכל אחד מהערכים המבוקשים (פרט, אולי לחציון, שאותו כבר בדקנו) נמצא בדיוק באחת מהן. \nתהי $B$ פרוסה באורך $m$, שכל ההופעות של $b$ נמצאות בה. נרשום $n/k=mn/mk=m/\\left(\\frac{m}{n}k\\right)$, ובהתאם נסמן $k':=\\frac{m}{n}k$ (לא בהכרח שלם). אז $b$ מופיע ב-$A$ יותר מ-$n/k$ פעמים אם ורק אם הוא מופיע יותר מ-$m/k'$ פעמים. קריאה רקורסיבית ל-`FindFrequent` עם גבולות הפרוסות והערכים $k'$ המתאימים יניבו לנו את האיברים המבוקשים.\n\nבפסודוקוד שלהלן, נניח שיש בידינו גרסאות של `FindFrequentBase`, `Select` ו-`Count` שמקבלות גם זוג אינדקסים $p,r$ ופועלות רק על הפרוסה $A[p..r]$.\n``` {.numberLines}\nFindFrequent(A,k,p,r)\n  if k ≤ 4\n    return FindFrequentBase(A,k,p,r)\n\n  n ← r-p+1\n  median ← Select(A, floor(n/2), p, r)\n  c ← Count(A, median, p, r)\n  if c > ⌊n/k⌋\n    output median\n\n  ▷ Partition and search subarrays\n  q ← Partition(A, p, r, median)\n  k1 ← (q-p)/n * k\n  FindFrquent(A, k1, p, q-1)\n  k2 ← (r-q)/n * k\n  FindFrquent(A, k2, q+1, r)\n```\nוהקריאה החיצונית ל-`FindFrquent` היא\n``` {.numberLines}\nFindFrquent(A, k)\n  FindFrquent(A, k, 1, n)\n```\n\nבאשר לסיבוכיות הזמן, השיטות `Count`,`Select` ו-`Partition` כולן רצות בזמן לינארי על גודל הפרוסה $A[p..r]$, ו-`Partition` מחלקת את המערך לשתי פרוסות כמעט שוות בגודל $\\floor{n/2}, \\ceil{n/2}-1$. ערכי הרצפה והתקרה, כמו גם ההזזה ב-1, לא משנות את סדר הגודל האסימפטוטמי של זמן הריצה, לכן סיבוכיות הזמן נתונה ע\"י פתרון נוסחת הנסיגה\n$$T(n, k)=2T\\left(\\frac{n}{2}, \\frac{k}{2}\\right)+\\Theta(n)$$\nמכאן נמשיך כמו בפתרון שאלה 9.3-6 בספר (או ו'-13 במדריך), שבה מתקבלת הנוסחה הזו בדיוק: נבנה את עץ הרקורסיה. גובה העץ הוא המספר המינימלי $i$ כך ש-$k/2^i\\le 4$, או באופן שקול $i=\\ceil{ \\log (k)-2}$, לכן גובה העץ הוא $\\Theta(\\log k)$.\nברמה ה-$d$ יש לכל היותר $2^d$ צמתים, והעלות של כל צומת בה היא $\\Theta(n/2^d)$, לכן העלות של כל רמה היא $O(n)$, והחסם העליון הזה אכן מתקבל, למשל כשהעץ מלא. \nלכן, במקרה הגרוע סיבוכיות הזמן היא $\\Theta(n\\log k)$.\n\nסיבוכיות המקום של `FindFrequent`, בלי הקריאות הרקורסיביות, היא $\\Theta(1)$. עומק עץ הרקורסיה, כמו שראינו, הוא $\\Theta(\\log k)$, ולכן יש בו $\\Theta(k)$ עלים, כלומר סיבוכיות המקום היא $\\Theta(k)$. $\\square$"
}