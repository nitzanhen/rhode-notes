{
  "id": "31",
  "name": "מנמ\"א ממ\"ן 12 שאלה 2",
  "body": "בהשראת בעיה 6-3 מהספר, נכנה טבלה כפי שמתוארת בשאלה **טבלת יאנג**. בהינתן טבלה $A$ כזו בגודל $m\\times n$, נכנה את $m$ **הגובה** של הטבלה ואת $n$ **הרוחב** שלה – בפסודוקוד, $m=\\operatorname*{height}[A], n=\\operatorname*{width}[A]$.\n\n### סעיף א'\nנדרש לכתוב אלגוריתם שמקבל טבלת יאנג $A$ ומספר $k$, ומחזיר את מקומו בטבלה, או $0$ אם הוא לא נמצא:\n``` {.numberLines}\nSearch-Young(A, k)\n  m ← height[A]\n  n ← width[A]\n  i ← 1\n  j ← n\n  while j ≥ 1 and i ≤ m\n    v ← A[i,j]\n    if v = k\n      return i,j\n    else if v > k\n      j ← j-1  ▷ go left\n    else\n      i ← i+1  ▷ go down\n  return 0  ▷ not found\n\n```\n\n(הערה: אם האיבר נמצא בטבלה מוחזר כאן הזוג $i,j$, אבל בהתאם להנחיות אם הוא לא נמצא מוחזר $0$; במימוש אמיתי אולי היה הגיוני לשנות את הערך המוחזר כך שיחזיר את המקום ה\"משוטח\", למשל $mi+j$ במקום הזוג $i,j$, כדי שיתאים לטיפוס הערך $0$, אבל זה לא מהותי לרעיון האלגוריתם)\n\n**נכונות**: נכנה זוג אינדקסים $r,c$ **טוב** אם $A[r,c]=k$. רעיון האלגוריתם דומה לרעיון האלגוריתם החיפוש עם ה\"אצבעות\" מממ\"ן 11 (אלגוריתם ב' בשאלה 3): מתחילים מהפינה הימנית העליונה של הטבלה, ובכל שלב, אם לא נמצא הערך המבוקש, הולכים שמאלה או למטה, עד שמגיעים לקצה הטבלה. בחירת הצעד מנצלת את המיון של הטבלה בשורות והעמודות כדי להבטיח שלא מתפספס זוג אינדקסים טוב; ביתר פירוט, נוכיח ששמורת הלולאה הבאה מתקיימת: \nבתחילת כל איטרציה, אם קיים זוג אינדקסים טוב $r,c$, אז $r\\ge i, c\\le j$.\n- **אתחול**: בתחילת האיטרציה הראשונה מתקיים $i=1,j=n$, ובשל ממדי הטבלה כל מקום $(r,c)$ מקיים $r\\ge 1, c\\le n$.\n- **תחזוקה**: נניח ששמורת הלולאה מתקיימת בתחילת איטרציה מסוימת. אם האיטרציה הסתיימה, אז בפרט מתקיים $A[i,j]\\neq k$. נסמן ב-$i',j'$ את הערכים של $i,j$ בסוף האיטרציה, ונפרק למקרים:\n    - $A[i,j]>k$: אז $j'=j-1,i'=i$. עלינו להראות שאם יש אינדקסים טוב $r,c$ אז $r\\ge i', c\\le j'$ – בשל שמורת הלולאה, זוג אינדקסים כזה בהכרח מקיים $r\\ge i=i', c\\le j=j'+1$, לכן מספיק להראות שאין זוג $r\\ge i,c=j$ שהוא טוב. אבל הטבלה $A$ ממוינת בטורים, לכן לכל $r\\ge i$, \n$$A[r,j]\\ge A[i,j]\\gt k$$\nולכן $r,j$ לא זוג טוב, כנדרש.\n    - $A[i,j]\\lt k$: מוכח באופן אנלוגי למקרה הראשון: במקרה הזה $j'=j,i'=i+1$, ועלינו להראות שאין זוג אינדקסים טוב $r=i,c\\le j$. הטבלה $A$ ממוינת בשורות, לכן לכל $c\\le j$,\n$$A[i,c]\\le A[i,j]\\lt k$$\nולכן הזוג $i,c$ לא זוג טוב.\n- **סיום**: נניח שהלולאה לא סיימה מוקדם, כלומר לא נמצא זוג טוב. אז תנאי הכניסה של הלולאה כבר לא מתקיים, כלומר מתקיים $j=0$ או $i=m+1$; אבל משמורת הלולאה במקרה הזה, אם יש זוג אינדקסים טוב $r,c$ אז $r\\ge i\\gt m$ או $c\\le j\\lt 1$ וזה חורג מגבולות הטבלה, לכן לא אפשרי – כלומר לא קיים זוג כזה. כלומר, אם הלולאה לא מצאה זוג טוב אז לא קיים כזה בטבלה, ולכן האלגורתם תקין גם במקרה זה.\n\nלסיום, עלינו להוכיח שהלולאה אכן מסיימת לרוץ אחרי מספר סופי של צעדים; זה נובע משמורת הלולאה הבאה, שתעזור לנו גם בניתוח הסיבוכיות: בתחילת האיטרציה ה-$k$, מתקיים $i+(n-j)=k+1$. אכן, בתחילת האיטרציה הראשונה מתקיים $i+(n-j)=1+(n-n)=1$; אם זה מתקיים בתחילת האיטרציה ה-$k$, והאיטרציה מסתיימת, אז בסופה $i'=i+1,j'=j$ או $i'=i,j'=j-1$; בכל מקרה $i'+(n-j')=i'+(n-j)+1=k+1$. \n\nמתקיים $i\\le m, j\\ge 1$, ולכן $i+(n-j)\\le m+n-1$; לכן, האלגוריתם מבצע לכל היותר $m+n$ איטרציות, ובפרט הלולאה אכן מסתיימת אחרי מספר סופי של איטרציות.\n\n**סיבוכיות**: כאמור, האלגוריתם מבצע לכל היותר $m+n$ איטרציות, וכל איטרציה היא $\\Theta(1)$, לכן סיבוכיות הזמן של האלגוריתם היא $O(m+n)$. במקרה הגרוע ביותר, החיפוש מגיע לפינה השמאלית התחתונה ואז נכשל (זה מתקיים למשל עבור הטבלה שניתנה כדוגמה בשאלה, עבור $k=31$). במקרה הזה מגיעים לאיטרציה ה-$m+n$, ולכן סיבוכיות הזמן במקרה הגרוע היא $\\Theta(m+n)$.\nהאלגוריתם משתמש בחמישה משתני עזר, לכן סיבוכיות המקום היא $\\Theta(1)$. $\\square$\n\n### סעיף ב'\nנדרש לכתוב אלגוריתם שמקבל טבלת יאנג $A$ ומספר $k$, מכניס אותו במקום האיבר המקסימלי ומסדר את הטבלה מחדש כך שתהיה טבלת יאנג שוב. המימוש שואב השראה מ-`IncreaseKey(i, val)` משאלה 1:\n``` {.numberLines}\nInsert(A,k):\n  A[height[A], width[A]] = k\n  Youngify(A, height[A], width[A])\n```\n\nכש-`Youngify(A,i,j)` שואב השראה מהאלגוריתם `Max-Heapify(A, i)` מהספר, אלא שהוא מחליק את האיבר במעלה הטבלה במקום למטה:\n``` {.numberLines}\nYoungify(A,i,j)\n  largest ← (i,j)\n  if i > 1 and A[i-1,j] > A[largest]\n    largest ← (i-1,j)\n  if j > 1 and A[i,j-1] > A[largest]\n    largest ← (i,j-1)\n\n  if largest ≠ (i,j)\n    exchange A[largest] ↔ A[i,j]\n    Youngify(A, largest)\n```\n\n**נכונות**: נאמר שמקום $(i,j)$ בטבלה מקיים את **תכונת יאנג** אם $A[i,j]\\ge A[i-1,j],A[i,j-1]$ (ככל שאלה מוגדרים). בנוסף, נאמר ש-$(i,j)$ הוא ה**שורש** של הטבלה של כל האינדקסים שנמצאים משמאלו או מעליו, כלומר כל המקומות $(r,c)$ כך ש-$1\\le r\\le i, 1\\le c\\le j$; באופן שקול, נאמר שהטבלה **נפרשת תחת** $(i,j)$. לבסוף, נאמר שהטבלה שנפרשת ע\"י $(i,j)$ מקיימת את תכונת יאנג אם כל מקום בה מקיים אותה.\nנוכיח את הטענה הבאה באינדוקציה על $i+j$: אם כל מקום בטבלה שנפרשת תחת $(i,j)$ מקיימת את תכונת יאנג פרט, אולי, ל-$(i,j)$ עצמו, אז בסוף הריצה של `Youngify` הטבלה מקיימת את תכונת יאנג.\n- $i+j=2$: אז $i=j=1$, והטבלה שנפרשת תחת $(i,j)$ במקרה הזה מכילה רק את $(i,j)$. בפרט, תכונת יאנג מתקיימת באופן ריק.\n- נניח שהוכחנו את הטענה לכל זוג $(i,j)$ שמקיים $i+j\\lt n$, ונניח ש-$i+j=n$. אם $\\operatorname*{largest}=(i,j)$, אז $A[i,j]\\ge A[i-1,j],A[i,j-1]$ (ככל שהם מוגדרים), ולכן הוא מקיים את תכונת יאנג – לכן כל מקום בטבלה שנפרשת תחתיו מקיים אותה, כלומר הטבלה מקיימת את תכונת יאנג.\nאחרת,  $\\operatorname*{largest}=(i',j')$ הוא אחד מבין הזוגות $(i-1,j),(i,j-1)$. לפני הקריאה הרקורסיבית, $A[\\operatorname*{largest}]$ מוחלף עם $A[i,j]$, ומהגדרת $\\operatorname*{largest}$ נובע שאחרי החלפה, המקום $(i,j)$ מקיים את תכונת יאנג, ומנגד ייתכן שעתה המקום $\\operatorname*{largest}$ לא מקיים אותה. אבל שתי האפשרויות עבור $\\operatorname*{largest}$ מקיימות $i'+j'=n-1$, וכעת $\\operatorname*{largest}$ מקיים את תנאי הטענה; לכן בסוף הקריאה הרקורסיבית הטבלה שנפרשת תחתיו מקיימת את תכונת יאנג, ולכן גם הטבלה שנפרשת תחת $(i,j)$ מקיימת אותה.\n\n**סיבוכיות**: פרט לקריאה הרקורסיבית, זמן הריצה $T(i,j)$ של `Youngify` חסום ע\"י קבוע $C$. נוכיח באידוקציה ש-$T(i,j)=O(i+j)$:\n- $i+j=2$: אז $i=j=1$ בהכרח. במקרה הזה בהכרח $\\operatorname*{largest}=(1,1)$, ו-$T(1,1)\\le C\\lt 2C$.\n- נניח שהוכחנו את הטענה לכל זוג $i,j$ שמקיים $i+j\\lt n$, ונניח ש-$i+j=n$. אם $\\operatorname*{largest}=(i,j)$, אז $T(i,j)\\le C$. אחרת, $\\operatorname*{largest}=(i',j')$ הוא אחד מבין הזוגות $(i-1,j),(i,j-1)$. עבור שתי האפשרויות מתקיים $i'+j'=i+j-1$, ומהנחת האינדוקציה נסיק ש-\n$$T(i,j)\\le C+T(i',j')\\le C+C(i+j-1)=C(i+j)$$\nובכל מקרה מתקיים $T(i,j)\\le C(i+j)$, כנדרש.\nבדומה ל-`MaxHeapify`, במקרה הגרוע – שבו $A[i,j]\\lt A[r,c]$ לכל $1\\le r\\le i,1\\le c\\le j$, יתבצעו $i+j$ קריאות רקורסיביות, ולכן במקרה הגרוע סיבוכיות הזמן היא $\\Theta(i+j)$.\n\nהפונקציה `Insert` מבצעת השמה אחת ואז קוראת ל-`Youngify(A,m,n)`, לכן סיבוכיות הזמן שלה היא $\\Theta(m+n)$.\nסיבוכיות המקום של האלגוריתם, פרט לקריאה הרקורסיבית, היא $\\Theta(1)$; כאמור במקרה הגרוע מתבצעות $m+n$ קריאות רקורסיביות, לכן סיבוכיות המקום במקרה הגרוע היא $\\Theta(m+n)$. כדי להקטין אותה ל-$\\Theta(1)$, אפשר לשנות את `Youngify` לגרסה איטרטיבית:\n``` {.numberLines}\nYoungifyIterative(A)\n  i ← height[A]\n  j ← width[A]\n\n  largest ← (i,j)\n  do\n    exchange A[largest] ↔ A[i,j]\n    (i,j) ← largest\n    if i > 1 and A[i-1,j] > A[largest]\n      largest ← (i-1,j)\n    if j > 1 and A[i,j-1] > A[largest]\n      largest ← (i,j-1)\n  while largest ≠ (i,j)\n```\n\n(את השימוש ב-do-while אפשר להחליף בלולאת while רגילה, אם מעתיקים את שני בלוקי ה-if ומוסיפים אותם מתחת להגדרה הראשונית של `largest`, אך זה פחות אלגנטי לדעתי).\nתוכן האלגוריתם וניתוח הנכונות והסיבוכיות תקפים משיקולים דומים למקרה הרקורסיבי, עם השינויים המתחייבים (הוכחה בעזרת שמורת לולאה במקום אינדוקיה, למשל). \n\n\n### סעיף ג'\nנדרש לכתוב אלגוריתם שמקבל כקלט טבלת יאנג $A$ ומספר $k$, ומחזיר את $k$ האיברים הקטנים ביותר בטבלה.\nרעיון האלגוריתם הוא כזה: משתמשים בתור קדימויות $Q$ עם קיבולת $k$ (כלומר, ערימת מינימום שנשענת על מערך בגודל $k$), שהאיברים בו הם מקומות $(i,j)$ בטבלה, והמפתח של כל איבר יהיה $A[i,j]$. בשלב ראשון, התור מכיל רק את הפינה השמאלית העליונה (שבה נמצא הערך המינימלי בטבלה). אחר כך, מבצעים $k$ פעמים את הפעולות הבאות: מחלצים את המינימום מ-$Q$, שבאיטרציה ה-$l$ מצביע על האיבר ה-$l$ הכי קטן בטבלה, ופולטים אותו. במקומו, מכניסים לטבלה את שני הצמתים מימין למינימום ומתחתיו, כך ש-$Q$ מכיל את כל המועמדים להיות האיבר ה-$l+1$ הקטן ביותר בטבלה. \n\nלבסוף, בשל העובדה שלכל איבר בטבלה יש יותר מ\"מסלול\" אחד שמוביל אליו, עשוי להיווצר מצב שאיבר מוכנס פעמיים לתור הקדימויות. כדי למנוע זאת, נניח שלכל איבר בטבלה יש שדה בוליאני `searched` שניתן לעריכה (לפי שאלה שנשאלה בפורום של מטלה 2, מותר להניח זאת). כשמוסיפים איבר לתור מסמנים אותו, וכך כל איבר נסרק פעם אחת לכל היותר (באופן שמזכיר סריקת BFS בגרף).\n\n``` {.numberLines}\nFindSmallest(A, k)\n  create min heap Q[1..2k]\n  Insert(Q, (1, 1), A[1, 1])\n  searched[A[1, 1]] ← true\n\n  for l ← 1 to k\n    (i,j) ← ExtractMin(Q)\n    output (i,j)\n\n    ▷ Add children to Q\n    if i < height[A] and searched[A[i+1, j]] = false\n      Insert(Q, (i+1, j), A[i+1, j])\n    if j < width[A] and searched[A[i, j+1]] = false\n      Insert(Q, (i,j+1), A[i,j+1])\n```\n\n(הערה: ב-output הכוונה \"להכריז\" על הערך ככזה שמקיים את מה שמחפשים. במימוש אמיתי אפשר היה, נניח, ליצור רשימה או מבנה נתונים אחר ולהוסיף אותם אליו כשמוצאים, ובסוף להחזיר את הרשימה כולה, אבל זה לא מהותי לרעיון האלגוריתם).\n\nהפונקציות `Insert` ו-`ExtractMin` כאן טיפה שונות בסמנטיקה מאלה שמופיעות בספר (אבל מהותית הן שקולות):\n- `Insert(Q, x, key)` מכניסה את האיבר $x$ לתור $Q$ עם המפתח $\\operatorname*{key}$. סיבוכיות הזמן שלו היא $O(\\log k)$, והיא מתקבלת במקרה הגרוע (כלומר החסם הדוק).\n- `ExtractMin(Q)` מוציא ומחזיר את המינימום מ-$Q$. גם סיבוכיות הזמן שלו היא $O(\\log k)$. במקרה הגרוע, שבו הערימה $Q$ ממוינת (להבדיל מקיום תכונת הערימה בלבד), סיבוכיות הזמן של `ExtractMin` היא $\\Theta(\\log k)$, שכן זו שמה את האיבר האחרון – המקסימלי – בראש הערימה, ולכן הקריאה שלו ל-`MinHeapify` תדרוש $\\log k$ החלקות. \n- \nנשים לב בכל איטרציה, איבר אחד יוצא מהתור ומוכנסים לכל היותר שניים; לכן בסוף האיטרציה ה-$l$ יש לכל היותר $l$ איברים בתור, והוא אף פעם לא מתמלא.\n\nסיבוכיות הזמן של בניית התור לוקחת $\\Theta(1)$ (בגלל שהאיבר שמוכנס הוא הראשון, מתקיים $\\operatorname*{heap-size}(Q)=1$ ולכן ההכנסה מתבצעת בזמן קבוע). כל איטרציה בלולאה היא $O(\\log k)$, כי זו הסיבוכיות של `ExtractMin` ושל `Insert`. לכן סיבוכיות הזמן הכוללת היא $O(k\\log k)$.\nבמקרה הגרוע ביותר, התור $Q$ שנוצר נשאר ממוין לאורך כל ריצת האלגוריתם, ואז כל איטרציה לוקחת $\\Theta(\\log k)$, כלומר סיבוכיות הזמן במקרה הגרוע היא $\\Theta(k\\log k)$.\n\nסיבוכיות המקום היא $\\Theta(\\log k)$, שכן פרט למשתני עזר האלגוריתם משתמש רק בתור $Q$, והקיבולת שלו היא $k$. $\\square$\n\n"
}