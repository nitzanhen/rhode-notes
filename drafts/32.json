{
  "id": "32",
  "name": "מנמ\"א ממ\"ן 12 שאלה 3",
  "body": "לאורך השאלה, כדי לציין שמערך $A$ כמעט ממוין עם שגיאה בגודל $k$ נאמר גם ש-$A$ ממוין עד כדי שגיאה בגודל $k$, או ש-$A$ $k$-כמעט-ממוין.\n\n### סעיף א'\nבאלגוריתם המקורי של מיון מהיר `Quicksort(A,p,r)`, תנאי העצירה של הרקורסיה הוא ש-$r\\le p$, כלומר שהפרוסה מתוך המערך שיש למיין ריקה; אם נשנה את התנאי כך שהרקורסיה תעצור כשגודל הפרוסה קטן מ-$k$, האלגוריתם ימיין את המערך רק עד כדי שגיאה בגודל $k$:\n``` {.numberLines}\nAlmostQuicksort(A, p, r):\n  if r-p ≥ k:\n    q ← Partition(A,p,r)\n    Quicksort(A, p, q-1)\n    Quicksort(A, p, q+1)\n```\n\n(`Partition` היא אלגוריתם החלוקה כמו שהוצג בספר). נוכיח שהאלגוריתם פועל כנדרש באינדוקציה על גודל המערך, $n$:\n- אם $n\\le k$, אז  במקרה הזה `AlmostQuicksort` לא עושה כלום, אבל מנגד אין $1\\le i,j\\le n$ שמקיימים $j-i\\gt k$, כלומר התנאי מתקיים באופן ריק ו-$A$ כבר ממוין עד כדי שגיאה בגודל $k$.\n- יהי $n\\gt k$, ונניח שהוכחנו את הטענה לכל $m\\lt n$. הפונקציה `Partition` משנה את המערך ומחזירה אינדקס $q$ כך שלכל $i\\le q\\le j$ מתקיים $A[i]\\le A[q]\\le A[j]$, ומהנחת האינדוקציה המיון ממיין את הפרוסות $A[1..q-1],A[q+1..n]$ עד כדי שגיאה בגודל $k$. \nנניח ש-$i\\lt j$ אינדקסים שעבורם מתקיים $A[i]\\gt A[j]$, אחרי המיון. לא ייתכן ש-$i\\le q\\le j$ – שכן אחרת כאמור $A[i]\\le A[q]\\le A[j]$ – לכן בהכרח מתקיים $i\\lt j\\le q$ או $q\\le i\\lt j$, כלומר $i,j$ שייכים לאותה פרוסה. אבל הפרוסות $A[1..q-1],A[q+1..n]$ שתיהן ממוינות עד כדי שגיאה בגודל $k$, לכן בהכרח $j-i\\le k$.\nאם כן, המערך כולו ממוין עד כדי שגיאה בגודל $k$.\n\nנמצא את הסיבוכיות של `AlmostQuicksort` במקרה הטוב ובמקרה הגרוע: \nההבדל העיקרי מהניתוח בספר הוא שכאן הסיבוכיות של $T(n)$, עבור $n\\le k$, קבועה.\nבמקרה הגרוע, כפי שמוסבר בספר, החלוקה יוצרת בכל שלב פרוסה אחת ריקה ופרוסה אחת שמכילה איבר אחד פחות, כלומר מתקבלת נוסחת הנסיגה\n$$T(n)=T(n-1)+f(n)$$\nכש-$f(n)=\\Theta(n)$ היא סיבוכיות הזמן של `Partition`. באינדוקציה נקבל שלכל $i$ \"קטן\",\n$$T(n)=T(n-i)+\\sum_{j=0}^{i}f(n-j)$$\nאת האינדוקציה נמשיך עד ש-$n-i=k$, כלומר $i=n-k$, ואז נקבל\n$$T(n)=T(k)+\\sum_{j=0}^{n-k}f(n-j)=\\Theta(1)+\\sum_{j=k}^nf(j)$$\nמתקיים $f(n)=\\Theta(n)$, לכן יש קבועים $c_1,c_2\\gt 0$ ו-$n_0$ שהחל ממנו, $c_1n\\le f(n)\\le c_2$. בה\"כ $k\\ge n_0$ – אחרת נפצל את הסכום\n$$\\sum_{j=k}^nf(j)=\\sum_{j=k}^{n_0}f(j)+\\sum_{j=n_0+1}^nf(j)$$\nוהמחובר הראשון מימין הוא קבוע (לא תלוי ב-$n$), לכן למחובר הימני אותו סדר גודל כמו הסכום המקורי. אם כן, נרשום\n$$c_1\\sum_{j=k}^nj\\le \\sum_{j=k}^nf(j)\\le c_2\\sum_{j=k}^nj$$\nו-\n$$2\\sum_{j=k}^nj=2\\sum_{j=1}^nj-2\\sum_{j=1}^kj=n(n+1)-k(k+1)=n^2-k^2+n-k=\\Theta(n^2-k^2)$$\nכשהמעבר האחרון מסתמך על כך ש-$n^2-k^2=(n+k)(n-k)\\ge n-k$ ו-$\\Theta(f+g)=\\Theta(\\max(f, g))$. לכן\n$$T(n)=\\Theta\\left(\\sum_{j=k}^nf(j)\\right)=\\Theta\\left(\\sum_{j=k}^nj\\right)=\\Theta(n^2-k^2)$$\n\nבמקרה הטוב, החלוקה יוצרת בכל שלב פרוסות מאוזנות ככל שניתן, כלומר אחת בגודל $\\floor{\\frac{n}{2}}$ ואחת בגודל $\\ceil{\\frac{n}{2}}-1$. ערכי הרצפה והתקרה, כמו גם ההזזה ב-$1$, לא משפיעים על סיבוכיות הבעיה, ולכן נוכל למצוא אותה ע\"י נוסחת הנסיגה\n$$T(n)=2T(n/2)+f(n)$$\nכש-$f(n)=\\Theta(n)$ כמו מקודם. כעת נקבל באינדוקציה\n$$T(n)=2^iT\\left(\\frac{n}{2^i}\\right)+\\sum_{j=0}^i{2^jf\\left(\\frac{n}{2^j}\\right)}$$\nאת האינדוקציה אפשר להמשיך כל עוד $n/2^i\\gt k$, כלומר עד ש-\n$$\\frac{n}{2^{i+1}}\\le k\\Longleftrightarrow i+1\\ge \\log\\left(\\frac{n}{k}\\right)$$\nכלומר עד $i=\\ceil{\\log(n/k)}$. כמו מקודם, ערך התקרה לא משנים את סדר הגודל, לכן אפשר להתעלם ממנו. בנוסף, כמו מקודם, אפשר להניח בה\"כ ש-$k\\ge n_0$, לכן $c_1n \\le 2^if(n/2^i)\\le c_2n$ ולכן\n$$c_1(i+1)n\\le\\sum_{j=0}^i{2^jf\\left(\\frac{n}{2^j}\\right)}\\le c_2(i+1)n$$\nיחד נקבל\n$$T(n)=2^{\\log(n/k)}T\\left(\\frac{n}{2^{\\log(n/k)}}\\right)+\\sum_{j=0}^i{2^jf\\left(\\frac{n}{2^j}\\right)}=\\frac{n}{k}\\Theta(1)+\\Theta\\left(\\left(\\log(n/k)+1\\right)n\\right)=\\Theta(n\\log(n/k))$$\nכשמעבר האחרון השתמשנו בכך ש-$n/k\\le n\\le n\\log(n/k)$ וש-$\\Theta(f+g)=\\Theta(\\max(f, g))$. $\\square$\n\n### סעיף ב'\nעבור מיון הכנסה על מערך $k$-כמעט ממוין, המקרה הטוב הוא שהמערך כבר ממוין – בדיוק כמו עבור מערך כללי – וזמן הריצה האסימפטוטי במקרה הזה הוא $\\Theta(n)$. היתרון של מיון עד כדי שגיאה בגודל $k$ בא לידי ביטוי במקרה הגרוע: \n\nנוכיח שאם המערך $A$ הוא $k$-כמעט-ממוין בתחילת האיטרציה של הלולאה החיצונית של מיון הכנסה (אני עובד מול הפסודו-קוד `(A)Insertion-Sort` שמופיע בפרק 2.1 בספר) אז הוא כזה גם בסופה: יהיו $i, j$ אינדקסים שמקיימים $j-i>k$. אז $A[i]\\le A[j]$ בתחילת האיטרציה, ועלינו להראות שזה מתקיים גם בסופה. \nנניח שאנחנו באיטרציה ה-$l$. \n- משמורת הלולאה של מיון הכנסה שמוצגת בפרק 2.2, בסוף האיטרציה הפרוסה $A[1..l]$ ממוינת, לכן אם $j\\le l$ אז $i\\lt j\\le l$ בחלק הממוין ולכן $A[i]\\le A[j]$.\n- בנוסף, במהלך האיטרציה ה-$l$ רק הפרוסה $A[1..l]$ משתנה, כלומר אם $i\\ge l+1$ אז האיברים $A[i],A[j]$ לא משתנים, ולכן $A[i]\\le A[j]$.\n- לכן, נניח ש-$i\\le l$ ו-$j\\gt l$. אז $A[j]$ לא משתנה במהלך האיטרציה, ו-$A[i]$ עשוי להשתנות. אם הוא לא משתנה, מובן שעדיין מתקיים $A[i]\\le A[j]$. אם הוא כן משתנה, זה יכול לקרות בשתי דרכים: או ש-$A[i]\\leftarrow A[i-1]$, זאת במקרה ש-$i=l$, כלומר $A[i]$ מוכנס למערך והוא לא מקסימלי; או ש-$A[i]\\leftarrow A[l]$, זאת כשהאיבר החדש מוכנס במקום ה-$i$. במקרה הראשון מתקיים $A[i-1]\\le A[i]\\le A[j]$ כי הפרוסה $A[1..l]$ ממוינת, וגם במקרה השני מתקיים $A[l]\\le A[i]\\le A[j]$ (אחרת האיבר ה-$l$ לא היה מוכנס לפני האיבר ה-$i$).\nבכל מקרה, מתקיים $A[i]\\le A[j]$ גם בסוף האיטרציה, לכן המערך נשאר $k$-כמעט-ממוין.\n\nנשתמש בשמורת הלולאה הזו כדי להראות שסיבוכיות הזמן של המיון במקרה הגרוע היא $\\Theta(nk)$:\nבכיוון אחד, נתבונן באיטרציה ה-$l$. מתנאי הכניסה של לולאת ה-while נסיק, שהיא ממשיכה עד שנמצא אינדקס $i\\lt l$ עם $A[i]\\le A[l]$ (או עד ש-$i=0$, אם לא נמצא כזה). אבל מהטענה שהוכחנו נסיק שבאיטרציה הזו המערך הוא $k$-כמעט-ממוין, לכן בהכרח מתקיים $A[l-(k+1)]\\le A[l]$ (כי ההפרש ביניהם גדול מ-$k$), ולכן הלולאה הפנימית מבצעת לכל היותר $k$ איטרציות. שאר התוכן של איטרציה של הלולאה החיצונית הוא $\\Theta(1)$ והיא מבצעת $n-1$ איטרציות, לכן נסיק שזמן הריצה הכולל במקרה הגרוע הוא $O(nk)$.\n\nבאשר לחסם תחתון, נשים לב שמערך שממוין בסדר יורד (שזה המקרה הכללי הגרוע ביותר עבור מיון הכנסה) אינו $k$-כמעט-ממוין, עבור $k\\lt n$. מצד שני, לא נתקשה למצוא דוגמא שזמן הריצה שלה הוא $\\Omega(nk)$: \nנרשום $n=qk+r$ חלוקה עם שארית, ונניח שהמערך מורכב מ-$q+1$ סדרות יורדות, כל אחת באורך $k$ (חוץ מהאחרונה שהיא באורך $r$), ושכל איבריה של כל סדרה קטנים ממש מכל איבריה של הסדרה שבאה אחריה. \nבדוגמה זו, באיטרציה ה-$ak+b$ הלולאה הפנימית תבצע בדיוק $b-1$ איטרציות, כי $A[ak+b]\\le A[ak+c]$ לכל $1\\le c\\le b$ אבל $A[ak+b]\\gt A[i]$ לכל $i\\lt ak+1$. \nלכן, אם נתעלם מהאיטרציות של השארית, זמן הריצה של האלגוריתם במקרה הזה יהיה\n$$T(n)\\ge q\\sum_{i=1}^k(i-1)=q\\sum_{i=1}^{k-1}=q\\frac{k(k-1)}{2}=\\frac{1}{2}(n-r)(k-1)=\\Omega(nk)$$\n($r$ אינו קבוע, אבל הוא חסום ע\"י $k$, לכן אחרי פתיחת הסוגריים כל הגורמים יהיו זניחים ביחס ל-$nk$).\nלכן, במקרה הגרוע ביותר זמן הריצה יהיה לפחות $T(n)$, כלומר $\\Omega(nk)$. יחד נקבל שבמקרה הגרוע זמן הריצה הוא $\\Theta(nk)$, כנדרש. $\\square$\n\n### סעיף ג'\nנדרש לכתוב אלגוריתם שממיין מערך $k$-כמעט-ממוין בעזרת ערימה:\n``` {.numberLines}\nHeapAlmostSort(A)\n  ▷ Build a min heap with values A[1],...,A[k]\n  Create array h[1..k]\n  for i ← 1 to k\n    h[i] ← A[i]\n  BuildMinHeap(h)\n\n  ▷ Main loop\n  for i ← 1 to n-k\n    A[i] ← Min(h)\n    IncreaseKey(h, 1, A[i+k])\n\n  ▷ Add the remaining elements in order\n  for i ← n-k+1 to n\n    A[i] ← ExtractMin(h)\n```\n\n(הפונקציות `(h)BuildMinHeap` ו-`ExtractMin(h)` הן המקבילות של פעולות הערימה `ExtractMax`, `BuildMaxHeap` שהוצגו בספר עבור ערימת מינימום; `IncreaseKey(A,i,val)` הוא האלגוריתם שהוגדר בשאלה 1).\n\nלפני שננתח את האלגוריתם, נסמן ב-$a_i$ את האיבר ה-$i$ הכי קטן במערך. נשים לב שבגלל שהמערך $k$-כמעט-ממוין, $a_i$ נמצא בפרוסה $A[1..i+k-1]$, שכן לכל $j\\ge i+k$, כל האיברים $A[1],...,A[j-k]$ קטנים או שווים ל-$A[j]$, ויש לפחות $i$ כאלה. \nרעיון האלגוריתם הוא אפוא לבנות ערימת מינימום של $k$ האיברים הראשונים, שהמינימום שלה יהיה כמובן האיבר הקטן במערך. בכל איטרציה בלולאה המרכזית שמים את המינימום בערימה, שהוא בדיוק $a_i$, במקום המתאים, ובמקומו מכניסים לערימה את האיבר ה-$i+k$, כך שהיא בוודאות תכיל את $a_{i+1}$. בשלב מסוים לקראת הסוף נגמרים האיברים לשים בערימה, ואז נותר רק לחלץ את האיברים מהערימה למקומות שנותרו במערך.\n\n**נכונות**: נוכיח את שמורת הלולאה הבאה עבור הלולאה המרכזית: בתחילת האיטרציה ה-$i$, \n1. תת המערך $A[1..i-1]$ ממוין ומכיל את $a_1,...,a_{i-1}$\n2.  כל איבר בפרוסה $A[1..i+k-1]$ נמצא או בפרוסה $A[1..i-1]$ או ב-$h$, ולא בשניהם.\n\n- **אתחול**: באיטרציה הראשונה, תת המערך $A[1..0]$ ריק, לכן $(1)$ מתקיים באופן ריק. בנוסף, הערימה $h$ מאותחלת לפני הלולאה עם הערכים $A[1..k]$, לכן $(2)$ מתקיים.\n- **תחזוקה**: נניח ששמורת הלולאה מתקיימת בתחילת האיטרציה ה-$i$. אז תת המערך $A[1..i-1]$ ממוין ומכיל את $a_1,...,a_{i-1}$. בפרט, $a_i$ לא נמצא ב-$A[1..i-1]$, אבל מצד שני הוא כן נמצא בפרוסה $A[1..i+k-1]$ לפי הטענה שהראנו לעיל, לכן הוא בהכרח נמצא ב-$h$. יותר מכך, הוא בהכרח נמצא בראשה, שכן אחרת בראשה יש איבר קטן ממנו, וכל האיברים שקטנים ממנו כבר אינם בערימה (הם ממלאים בדיוק את הפרוסה $A[1..i-1]$). אז הפעולה $\\operatorname*{Min}(h)$ נותנת לנו את $a_i$, והוא מושם במקומו המתאים ($A[i]$), לכן $(1)$ מתקיים. בשורה הבאה האיבר $A[i+k]$ מוכנס לערימה במקום $a_i$. אז $a_1,...,a_i$ נמצאים כולם במקומות $1,...,i$ בהתאמה, וכל שאר האיברים של הפרוסה $A[1..i+k]$ נמצאים בערימה $h$, לכן גם $(2)$ מתקיים.\n- **סיום**: בסיום הלולאה מתקיים $i=n-k+1$, לכן משמורת הלולאה מתקיים:\n  1. תת המערך $A[1..n-k]$ ממוין ומכיל את $a_1,...,a_{n-k}$\n  2. כל איבר ב-$A[1..n]=A$ נמצא או ב-$A[1..n-k]$ או ב-$h$, ולא בשניהם.\n  מכך נסיק שהאיברים שנותרו בערימה הם בדיוק $a_{n-k+1},...,a_n$, ונותר לשבץ אותם במקומות $A[n-k+i],...,A[n]$ לפי הסדר; הפעולה `ExtractMin(h)` בלולאה האחרונה מוציאה בכל שלב את הקטן שבהם ושמה אותו במקום. לכן, בסופה מתקיים $A[i]=a_i$ לכל $1\\le i\\le n$, כנדרש.\n\n\n**סיבוכיות**: נפרק את חישוב סיבוכיות הזמן לשלבים:\n1. בחלק הראשון, יצירת המערך עם הערכים הנדרשים לוקח $\\Theta(k)$, ו-$\\operatorname*{BuildMinHeap}(h)$ גם רץ בזמן לינארי עם גודל הערימה, כלומר $\\Theta(k)$. יחד, סיבוכיות הזמן של החלק הראשון היא $\\Theta(k)$.\n2. הלולאה המרכזית עוברת $n-k$ איטרציות. `IncreaseKey` רצה בזמן $\\Theta(\\log k)$ במקרה הגרוע, לכן סיבוכיות הזמן של הלולאה היא $\\Theta((n-k)\\log k)$.\n3. גם הסיבוכיות של `ExtractMin` היא $\\Theta(\\log k)$ במקרה הגרוע, לכן סיבוכיות הזמן של הלולאה האחרונה היא $\\Theta(k\\log k)$.\n\nביחד, הלולאה השנייה והשלישית מבצעות $n$ איטרציות של $\\Theta(\\log k)$ במקרה הגרוע, והחלק הראשון רץ בזמן $\\Theta(k)$. מתקיים $k<n<n\\log k$, לכן זמן הריצה הכולל הוא\n$$\\Theta(k+n\\log k)=\\Theta(n\\log k)$$\nסיבוכיות המקום של האלגוריתם היא $\\Theta(k)$, שכן הפעולה משתמשת בערימה בגודל $k$. $\\square$\n\n"
}