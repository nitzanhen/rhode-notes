{
  "id": "37",
  "name": "מנמ\"א ממ\"ן 14 שאלה 1",
  "body": "$S$ סדרה של $n$ מספרים שלמים בקטע $[n+1,...,n+p]$\n\n### סעיף א'\nנדרש לכתוב אלגוריתם שמוצא מספר ב-$S$ עם שכיחות מקסימלית:\n``` {.numberLines}\nMode(S, n, p)\n  # Build array of frequencies\n  Create array C[n+1..n+p]\n  for i ← n+1 to n+p\n    C[i] ← 0\n\n  for i ← 1 to n\n    val ← S[i]\n    C[val] ← C[val] + 1\n\n  # Find the arg-max in C\n  max-index ← n\n  max-val ← 0\n  for i ← n+1 to n+p\n    val ← C[i]\n    if val > max-val\n      max-index ← i\n      max-val ← val\n\n  return max-index\n```\n\n**נכונות**: בדומה למיון מנייה, בתום לולאת ה-for השנייה המערך $C$ יכיל את מספרי ההופעות של כל הערכים האפשריים $n+1,...,n+p$ ב-$S$; אינדקס במערך זה שבו מתקבל ערך מקסימלי הוא איבר עם שכיחות מקסימלית ב-$S$, וזה בדיוק מה שהלולאה השלישית מוצאת, ע\"י מעבר \"נאיבי\" על כל איברי המערך (בדומה לאלגוריתם למציאת המינימום/מקסימום של מערך מתחילת פרק 9).\n**סיבוכיות זמן**: הלולאה הראשונה והשלישית מבצעות $p$ איטרציות של $\\Theta(1)$, לכן רצות בזמן $\\Theta(p)$. הלולאה השנייה מבצעת $n$ איטרציות של $\\Theta(1)$, לכן רצה בזמן $\\Theta(n)$, ויחד סיבוכיות הזמן הכוללת היא $\\Theta(n+p)$, כנדרש.\n**סיבוכיות מקום**: מלבד המערך $C$ שגודלו $p$, הפעולה משתמשת במספר קטן של משתני עזר, לכן סיבוכיות המקום היא $\\Theta(p)$. $\\square$\n\n### סעיף ב'\nנדרש לכתוב אלגוריתם שמוצא זוג איברים $a,b$ ב-$S$, לאו דווקא שונים, כך שהשכיחויות שלהם גדולות מ-$1$ והסכום $a+b$ שווה לפרמטר נתון $z$:\n``` {.numberLines}\nFrequent-Summands(S, n, p, z)\n  # Build array of frequencies\n  Create array C[n+1..n+p]\n  for i ← n+1 to n+p\n    C[i] ← 0\n\n  for i ← 1 to n\n    val ← S[i]\n    C[val] ← C[val] + 1\n\n  # Iterate over each possible a, and check the difference b=z-a\n  for a ← n+1 to n+p\n    if C[a] ≤ 1\n      continue  # (to the next iteration)\n    b ← z - a\n    if n+1 ≤ b ≤ n+p and C[b] > 1\n      return a, b\n\n  return NIL\n```\n\n**נכונות**: תחילה, האלגוריתם מחשב את מספרי ההופעות של כל הערכים האפשריים, בדיוק באותו האופן כמו בסעיף א'.\nכעת, זוג $a,b$ כנדרש קיים אם ורק אם יש $a\\in [n+1,...,n+p]$ שמופיע במערך יותר מפעם אחת (כלומר $C[a]>1$), כך ש-$b:=z-a$ גם הוא מופיע במערך יותר מפעם אחת; התנאי הזה בדיוק נבדק בתוכן הלולאה השלישית (מכיוון שגבולות המערך $C$ הם $[n+1..n+p]$ וההפרש $b$ עשוי לחרוג מגבולות אלה – למשל במקרה ש-$z=2(n+p)$ ו-$a=n+1$ – אנו מוסיפים בדיקה מפורשת שהוא נמצא בטווח). לכן האלגוריתם מבצע את הדרוש. \nאעיר שבמימוש אמיתי אפשר היה לחסוך איטרציות מיותרות ע\"י חישוב גבולות הלולאה השלישית באופן מתוחכם יותר – למשל, כש-$z=2(n+p)$ הערך היחיד האפשרי עבור $a$ (וגם עבור $b$) הוא $n+p$, וכש-$z$ לא נמצא בטווח $[2(n+1),2(n+p)]$ בכלל לא יכול להיות זוג $a,b$ שמקיים את הנדרש. עם זאת, חיסכון האיטרציות לא היה משפר את הפתרון בסדר גודל אסימפטוטי במקרה הגרוע והוכחת הנכונות שלו דורשת נימוק מעמיק יותר, ולכן ויתרתי עליו כאן.\n**סיבוכיות זמן**: כמו בסעיף א', אתחול המערך $C$ אורך $\\Theta(p)$, וספירת השכיחויות אורכת $\\Theta(n)$. הלולאה השלישית מבצעת $p$ איטרציות של $\\Theta(1)$, לכן אורכת $\\Theta(p)$, וביחד נקבל סיבוכיות זמן של $\\Theta(n+p)$.\n**סיבוכיות מקום**: המערך $C$ דורש מקום של $\\Theta(p)$, ומלבדו מוגדרים רק כמה משתני עזר, לכן סיבוכיות המקום היא $\\Theta(p)$. $\\square$\n\n### סעיף ג'\nנדרש לחזור על סעיפים א' וב', כשהפעם נדרשת תוחלת זמן ריצה של $O(n)$. נקבל אותה אם נחליף את המערך $C$ בטבלת גיבוב $T$ בגודל $n$, עם פונקציית גיבוב $h$ שנותנת גיבוב אחיד ופשוט מ-$[n+1,...,n+p]$ אל $[1,...,n]$, ופתרון התנגשויות בעזרת שרשור:\n``` {.numberLines}\nMode-Hash(S, n, p)\n  # Create the table of frequencies T\n  Create hash table T[1..n]\n  for i ← 1 to n\n    num ← S[i]\n    freq ← Search(T, num)\n    if freq = NIL\n      freq ← 0\n    Insert(T, num, freq + 1) \n\n  # Find the arg-max in T \n  max-num ← n\n  max-freq ← 0\n  for i ← 1 to n\n    num ← S[i]\n    freq ← Search(T, num)\n    if freq > max-freq\n      max-num ← num\n      max-freq ← freq\n\n  return max-num\n```\n\nהפעולות `Search` ו-`Insert` פועלות על טבלת גיבוב כמו בספר, כש-`Insert` מקבלת את הטבלה, מפתח ואת הערך להכניס עבורו, ו-`Search` מקבלת את הטבלה ואת המפתח לחפש (אם הערך לא נמצא, ההנחה היא ש-`Search` מחזירה `NIL`).\n\n**נכונות**: בלולאה הראשונה אנחנו בונים את טבלת מספרי ההופעות $T$ (בדומה לבניית המערך $C$ מהסעיפים הקודמים): אנו משתמשים באיברי $S$ כמפתחות, ולכל איבר מתאימים את מספר ההופעות שלו במערך – ביתר פירוט, באיטרציה ה-$i$ שולפים את מספר ההופעות של האיבר $S[i]$ (או $0$ אם הוא לא נסרק עדיין) ומגדילים אותו באחד.\nבפרט, במהלך הלולאה עוברים על כל איברי $S$ – כלומר בסופה לכל $i$, $S[i]$ מופיע כמפתח ב-$T$ – ולכן חיפוש בטבלה של איבר מ-$S$ כמפתח (כמו שעושים, למשל, בלולאה השנייה) בהכרח יצליח, ולא יוחזר `NIL`.\n\nבהינתן הטבלה הבנויה $T$ של מספרי ההופעות, אנחנו מחפשים בה אינדקס שעבורו מתקבל ערך מקסימלי, ממש כמו שעשינו בסעיף א' (ההבדל היחיד הוא שבמקום לחפש ע\"י $C[\\operatorname*{num}]$ אנחנו מחפשים ע\"י $\\operatorname*{Search}(T, \\operatorname*{num})$). לכן האלגוריתם פועל כנדרש.\n\n**סיבוכיות זמן**: כעת, אנחנו מעוניינים בתוחלת זמן הריצה להבדיל מזמן הריצה במקרה הגרוע. \nתחילה, $T$ מאותחלת עם $n$ תאים, ולאורך כל הריצה יש בה לכל היותר $n$ איברים, לכן מקדם העומס $\\alpha$ קטן או שווה ל-$1$ לאורך כל הריצה; מכך נובע שתוחלת זמן החיפוש, בין אם הוא מצליח או נכשל, היא $\\Theta(1+\\alpha)=\\Theta(1)$ (לפי משפטים 11.1 ו-11.2 בספר). בנוסף, הכנסת איבר מתבצעת בזמן $\\Theta(1)$. מכך נובע שתוחלת זמן הריצה של כל איטרציה בלולאה הראשונה היא $\\Theta(1)$ (מלבד החיפוש, כל הפעולות אורכות $O(1)$), ומלינאריות התוחלת נקבל שתוחלת זמן הריצה של הלולאה הראשונה היא $\\Theta(n)$.\nגם הלולאה השנייה מבצעת $n$ איטרציות, ותוחלת זמן הריצה של כל אחת היא $\\Theta(1)$, לכן תוחלת זמן הריצה הכולל היא $\\Theta(n)$.\n**סיבוכיות מקום**: טבלת הגיבוב תופסת מקום $\\Theta(n)$, וחוץ ממנה משתמשים רק בכמה משתנים בודדים, לכן סיבוכיות המקום היא $\\Theta(n)$.\n\nבאשר לאלגוריתם השני:\n\n``` {.numberLines}\nFrequent-Summands-Hash(S, n, p, z)\n  # Create the table of frequencies T\n  Create hash table T[1..n]\n  for i ← 1 to n\n    num ← S[i]\n    freq ← Search(T, num)\n    if freq = NIL\n      freq ← 0\n    Insert(T, num, freq + 1)\n\n  # Iterate over each possible a, and check the difference b=z-a\n  for i ← 1 to n\n    a ← S[i]\n    if Search(T, a) ≤ 1\n      continue  ▷ (to the next iteration)\n    b ← z - a\n    if n+1 ≤ b ≤ n+p and Search(T, b) > 1\n      return a, b\n\n  return NIL\n```\n**נכונות**: ההבדל בין האלגוריתם כאן לאלגוריתם מסעיף ב' זהה במהותו להבדל בין האלגוריתם הקודם לזה מסעיף א' – במקום לבנות את המערך $C$ אנחנו בונים בלולאה הראשונה טבלת גיבוב $T$ של מספרי ההופעות של האיברים ב-$S$. אחר כך, בלולאה השנייה שוב עוברים על כל איבר $a$ ב-$S$, וכמו בסעיף ב' בודקים האם הוא מופיע יותר מפעם אחת (כעת בעזרת טבלת הגיבוב) והאם גם המשלים שלו $b:=z-a$ מופיע יותר מפעם אחת. לכן האלגוריתם פועל כנדרש.\n**סיבוכיות זמן**: כמו באלגוריתם הקודם, תוחלת זמן הריצה של הלולאה הראשונה היא $\\Theta(n)$. גם כאן, הלולאה השנייה מבצעת $n$ איטרציות שלכל אחת תוחלת זמן ריצה של $\\Theta(1)$, ולכן תוחלת זמן הריצה הכולל היא $\\Theta(n)$.\n**סיבוכיות מקום**: כמו באלגוריתם הקודם, סיבוכיות המקום היא $\\Theta(n)$. $\\square$"
}